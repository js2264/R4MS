[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Mass Spectrometry",
    "section": "",
    "text": "Welcome\nThe aim of the R for Mass Spectrometry initiative is to provide efficient, thoroughly documented, tested and flexible R software for the analysis and interpretation of high throughput mass spectrometry assays, including proteomics and metabolomics experiments. The project formalises the longtime collaborative development efforts of its core members under the RforMassSpectrometry organisation to facilitate dissemination and accessibility of their work.\nThis material introduces participants to the analysis and exploration of mass spectrometry (MS) based proteomics data using R and Bioconductor. The course will cover all levels of MS data, from raw data to identification and quantitation data, up to the statistical interpretation of a typical shotgun MS experiment and will focus on hands-on tutorials. At the end of this course, the participants will be able to manipulate MS data in R and use existing packages for their exploratory and statistical proteomics data analysis.\nA Docker image built from this repository is available here:\nüëâ ghcr.io/js2264/r4ms üê≥\nAn RStudio Server instance can be initiated from the Docker image as follows:\nbash\n\ndocker run \\\n    --volume &lt;local_folder&gt;:&lt;destination_folder&gt; \\\n    -e PASSWORD=OHCA \\\n    -p 8787:8787 \\\n    ghcr.io/js2264/r4ms:devel\nThe initiated RStudio Server instance will be available at https://localhost:8787."
  },
  {
    "objectID": "index.html#targeted-audience-and-assumed-background",
    "href": "index.html#targeted-audience-and-assumed-background",
    "title": "R for Mass Spectrometry",
    "section": "Targeted audience and assumed background",
    "text": "Targeted audience and assumed background\nThe course material is targeted to either proteomics practitioners or data analysts/bioinformaticians that would like to learn how to use R and Bioconductor to analyse proteomics data. Familiarity with MS or proteomics in general is desirable, but not essential as we will walk through and describe a typical MS data as part of learning about the tools. For approachable introductions to sample preparation, mass spectrometry, data interpretation and analysis, readers are redirected to:\n\n\nA beginner‚Äôs guide to mass spectrometry‚Äìbased proteomics (Sinha and Mann 2020)\n\n\nThe ABC‚Äôs (and XYZ‚Äôs) of peptide sequencing (Steen and Mann 2004)\n\n\nHow do shotgun proteomics algorithms identify proteins? (Marcotte 2007)\n\n\nAn Introduction to Mass Spectrometry-Based Proteomics (Shuken 2023)\n\n\nA working knowledge of R (R syntax, commonly used functions, basic data structures such as data frames, vectors, matrices, ‚Ä¶ and their manipulation) is required. Familiarity with other Bioconductor omics data classes and the tidyverse syntax is useful, but not necessary."
  },
  {
    "objectID": "index.html#setup",
    "href": "index.html#setup",
    "title": "R for Mass Spectrometry",
    "section": "Setup",
    "text": "Setup\nThis material uses the latest version of the R for Mass Spectrometry package and their dependencies. It might thus be possible that even the latest Bioconductor stable version isn‚Äôt recent enough.\nTo install all the necessary package, please use the latest release of R and execute:\n\nif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nBiocManager::install(\"tidyverse\")\nBiocManager::install(\"factoextra\")\nBiocManager::install(\"msdata\")\nBiocManager::install(\"mzR\")\nBiocManager::install(\"rhdf5\")\nBiocManager::install(\"rpx\")\nBiocManager::install(\"MsCoreUtils\")\nBiocManager::install(\"QFeatures\")\nBiocManager::install(\"Spectra\")\nBiocManager::install(\"ProtGenerics\")\nBiocManager::install(\"PSMatch\")\nBiocManager::install(\"pheatmap\")\nBiocManager::install(\"limma\")\nBiocManager::install(\"MSnID\")\nBiocManager::install(\"RforMassSpectrometry/SpectraVis\")\n\nFollow the instructions in this script to install the packages and download some of the data used in the following chapters. All software versions used to generate this document are recoded at the end of the book in @ref(sec-si)."
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "R for Mass Spectrometry",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nThank you to Charlotte Soneson for fixing many typos in a previous version of this book."
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "R for Mass Spectrometry",
    "section": "License",
    "text": "License\nThis material is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. You are free to share (copy and redistribute the material in any medium or format) and adapt (remix, transform, and build upon the material) for any purpose, even commercially, as long as you give appropriate credit and distribute your contributions under the same license as the original."
  },
  {
    "objectID": "pages/introduction.html#how-does-mass-spectrometry-work",
    "href": "pages/introduction.html#how-does-mass-spectrometry-work",
    "title": "1¬† Introduction",
    "section": "\n1.1 How does mass spectrometry work?",
    "text": "1.1 How does mass spectrometry work?\nMass spectrometry (MS) is a technology that separates charged molecules (ions) based on their mass to charge ratio (M/Z). It is often coupled to chromatography (liquid LC, but can also be gas-based GC). The time an analyte takes to elute from the chromatography column is the retention time.\n\n\n\n\nA chromatogram, illustrating the total amount of analytes over the retention time.\n\n\n\nAn mass spectrometer is composed of three components:\n\nThe source, that ionises the molecules: examples are Matrix-assisted laser desorption/ionisation (MALDI) or electrospray ionisation. (ESI)\nThe analyser, that separates the ions: Time of flight (TOF) or Orbitrap.\nThe detector that quantifies the ions.\n\nWhen using mass spectrometry for proteomics, the proteins are first digested with a protease such as trypsin. In mass shotgun proteomics, the analytes assayed in the mass spectrometer are peptides.\nOften, ions are subjected to more than a single MS round. After a first round of separation, the peaks in the spectra, called MS1 spectra, represent peptides. At this stage, the only information we possess about these peptides are their retention time and their mass-to-charge (we can also infer their charge by inspecting their isotopic envelope, i.e the peaks of the individual isotopes, see below), which is not enough to infer their identify (i.e.¬†their sequence).\nIn MSMS (or MS2), the settings of the mass spectrometer are set automatically to select a certain number of MS1 peaks (for example 20)1. Once a narrow M/Z range has been selected (corresponding to one high-intensity peak, a peptide, and some background noise), it is fragmented (using for example collision-induced dissociation (CID), higher energy collisional dissociation (HCD) or electron-transfer dissociation (ETD)). The fragment ions are then themselves separated in the analyser to produce a MS2 spectrum. The unique fragment ion pattern can then be used to infer the peptide sequence using de novo sequencing (when the spectrum is of high enough quality) or using a search engine such as, for example Mascot, MSGF+, ‚Ä¶, that will match the observed, experimental spectrum to theoretical spectra (see details below).\n\n\n\n\nSchematics of a mass spectrometer and two rounds of MS.\n\n\n\nThe animation below show how 25 ions different ions (i.e.¬†having different M/Z values) are separated throughout the MS analysis and are eventually detected (i.e.¬†quantified). The final frame shows the hypothetical spectrum.\n\n\n\n\nSeparation and detection of ions in a mass spectrometer.\n\n\n\nThe figures below illustrate the two rounds of MS. The spectrum on the left is an MS1 spectrum acquired after 21 minutes and 3 seconds of elution. 10 peaks, highlited by dotted vertical lines, were selected for MS2 analysis. The peak at M/Z 460.79 (488.8) is highlighted by a red (orange) vertical line on the MS1 spectrum and the fragment spectra are shown on the MS2 spectrum on the top (bottom) right figure.\n\n\n\n\nParent ions in the MS1 spectrum (left) and two sected fragment ions MS2 spectra (right)\n\n\n\nThe figures below represent the 3 dimensions of MS data: a set of spectra (M/Z and intensity) of retention time, as well as the interleaved nature of MS1 and MS2 (and there could be more levels) data.\n\n\n\n\nMS1 spectra over retention time.\n\n\n\n\n\n\n\nMS2 spectra interleaved between two MS1 spectra."
  },
  {
    "objectID": "pages/introduction.html#accessing-data",
    "href": "pages/introduction.html#accessing-data",
    "title": "1¬† Introduction",
    "section": "\n1.2 Accessing data",
    "text": "1.2 Accessing data\n\n1.2.1 From the ProteomeXchange database\nMS-based proteomics data is disseminated through the ProteomeXchange infrastructure, which centrally coordinates submission, storage and dissemination through multiple data repositories, such as the PRoteomics IDEntifications (PRIDE) database at the EBI for mass spectrometry-based experiments (including quantitative data, as opposed as the name suggests), PASSEL at the ISB for Selected Reaction Monitoring (SRM, i.e.¬†targeted) data and the MassIVE resource. These data can be downloaded within R using the rpx package.\n\nlibrary(rpx)\n\nUsing the unique PXD000001 identifier, we can retrieve the relevant metadata that will be stored in a PXDataset object. The names of the files available in this data can be retrieved with the pxfiles accessor function.\n\npx &lt;- PXDataset(\"PXD000001\")\n##  Querying ProteomeXchange for PXD000001.\npx\n##  Project PXD000001 with 11 files\n##  \n##  Resource ID BFC1 in cache in /root/.cache/R/rpx.\n##   [1] 'F063721.dat' ... [11] 'erwinia_carotovora.fasta'\n##   Use 'pxfiles(.)' to see all files.\npxfiles(px)\n##  Project PXD000001 files (11):\n##   [remote] F063721.dat\n##   [remote] F063721.dat-mztab.txt\n##   [remote] PRIDE_Exp_Complete_Ac_22134.xml.gz\n##   [remote] PRIDE_Exp_mzData_Ac_22134.xml.gz\n##   [remote] PXD000001_mztab.txt\n##   [remote] README.txt\n##   [remote] TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##   [remote] TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzXML\n##   [remote] TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzXML\n##   [remote] TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.raw\n##   ...\n\nOther metadata for the px data set:\n\npxtax(px)\n##  [1] \"Erwinia carotovora\"\npxurl(px)\n##  [1] \"ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2012/03/PXD000001/generated\"\npxref(px)\n##  [1] \"Gatto L, Christoforou A; Using R and Bioconductor for proteomics data analysis., Biochim Biophys Acta, 2013 May 18, doi:10.1016/j.bbapap.2013.04.032 PMID:23692960\"\n\nData files can then be downloaded with the pxget function. Below, we retrieve the raw data file. The file is downloaded2 in the working directory and the name of the file is return by the function and stored in the mzf variable for later use 3.\n\nfn &lt;- \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\"\nmzf &lt;- pxget(px, fn)\n##  Downloading TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML file.\nmzf\n##  [1] \"/root/.cache/R/rpx/cdb6ce236_TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\"\n\n\n1.2.2 Data packages\nSome data are also distributed through dedicated packages. The msdata, for example, provides some general raw data files relevant for both proteomics and metabolomics.\n\nlibrary(msdata)\n## proteomics raw data\nproteomics()\n##  [1] \"MRM-standmix-5.mzML.gz\"                                                \n##  [2] \"MS3TMT10_01022016_32917-33481.mzML.gz\"                                 \n##  [3] \"MS3TMT11.mzML\"                                                         \n##  [4] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML.gz\"\n##  [5] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.gz\"\n## proteomics identification data\nident()\n##  [1] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\"\n## quantitative data\nquant()\n##  [1] \"cptac_a_b_peptides.txt\"\n\nMore often, such experiment packages distribute processed data; an example of such is the pRolocdata package, that offers quantitative proteomics data."
  },
  {
    "objectID": "pages/introduction.html#footnotes",
    "href": "pages/introduction.html#footnotes",
    "title": "1¬† Introduction",
    "section": "",
    "text": "Here, we will focus on data dependent acquisition (DDA), where MS1 peaks are selected. In data independent acquisition (DIA), all peaks in the MS1 spectrum are fragmented.‚Ü©Ô∏é\nIf the file is already available, it is not downloaded a second time.‚Ü©Ô∏é\nThis and other files are also availabel in the msdata package, described below‚Ü©Ô∏é"
  },
  {
    "objectID": "pages/raw-ms-data.html",
    "href": "pages/raw-ms-data.html",
    "title": "2¬† Raw MS data",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "pages/raw-ms-data.html#what-is-raw-data-in-r",
    "href": "pages/raw-ms-data.html#what-is-raw-data-in-r",
    "title": "2¬† Raw MS data",
    "section": "\n2.1 What is raw data in R",
    "text": "2.1 What is raw data in R\nWhen we manipulate complex data, we need a way to abstract it.\nThe abstraction saves us from having to know about all the details of that data and its associated metadata. In R, we think of MS data as illustrated on the figure below (taken from (Gatto, Gibb, and Rainer 2020)): a metadata table and a set of raw spectra. This allows to rely on a few easy-to-remember conventions to make mundane and repetitive tasks trivial and be able to complete more complex things easily. Abstractions provide a smoother approach to handle complex data using common patterns.\n\n\n\n\nSchematic representation of what is referred to by raw data: a collection of mass spectra and a table containing spectrum-level annotations along the lines. Raw data are imported from one of the many community-maintained open standards formats (mzML, mzXML, mzData or ANDI-MS/netCDF).\n\n\n\n\n2.1.1 The Spectra class\nWe are going to use the Spectra package as an abstraction to raw mass spectrometry data.\n\nlibrary(Spectra)\n\nSpectra is part of the R for Mass Spectrometry initiative. It defines the Spectra class that is used as a raw data abstraction, to manipulate MS data and metadata. The best way to learn about a data structure is to create one by hand.\nLet‚Äôs create a DataFrame1 containing MS levels, retention time, m/z and intensities for 2 spectra:\n\nspd &lt;- DataFrame(msLevel = c(1L, 2L), rtime = c(1.1, 1.2))\nspd$mz &lt;- list(c(100, 103.2, 104.3, 106.5), c(45.6, 120.4, 190.2))\nspd$intensity &lt;- list(c(200, 400, 34.2, 17), c(12.3, 15.2, 6.8))\nspd\n##  DataFrame with 2 rows and 4 columns\n##      msLevel     rtime                    mz             intensity\n##    &lt;integer&gt; &lt;numeric&gt;                &lt;list&gt;                &lt;list&gt;\n##  1         1       1.1 100.0,103.2,104.3,... 200.0,400.0, 34.2,...\n##  2         2       1.2      45.6,120.4,190.2        12.3,15.2, 6.8\n\nAnd now convert this DataFrame into a Spectra object:\n\nsp0 &lt;- Spectra(spd)\nsp0\n##  MSn data (Spectra) with 2 spectra in a MsBackendMemory backend:\n##      msLevel     rtime scanIndex\n##    &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1         1       1.1        NA\n##  2         2       1.2        NA\n##   ... 16 more variables/columns.\n\nExercise\nExplore the newly created object using\n\n\nspectraVariables to extract all the metadata variables. Compare these to the spectra variables available from the previous example.\n\nspectraData to extract all the metadata.\n\npeaksData to extract a list containing the raw data.\n\n[ to create subsets.\n\n2.1.2 Spectra from mzML files\nLet‚Äôs now create a new object using the mzML data previously downloaded and available in the mzf file.\n\nlibrary(rpx)\nfn &lt;- \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\"\npx &lt;- PXDataset(\"PXD000001\")\n##  Loading PXD000001 from cache.\nmzf &lt;- pxget(px, fn)\n##  Loading TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML from cache.\nmzf\n##  [1] \"/root/.cache/R/rpx/cdb6ce236_TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\"\nsp &lt;- Spectra(mzf)\nsp\n##  MSn data (Spectra) with 7534 spectra in a MsBackendMzR backend:\n##         msLevel     rtime scanIndex\n##       &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1            1    0.4584         1\n##  2            1    0.9725         2\n##  3            1    1.8524         3\n##  4            1    2.7424         4\n##  5            1    3.6124         5\n##  ...        ...       ...       ...\n##  7530         2   3600.47      7530\n##  7531         2   3600.83      7531\n##  7532         2   3601.18      7532\n##  7533         2   3601.57      7533\n##  7534         2   3601.98      7534\n##   ... 33 more variables/columns.\n##  \n##  file(s):\n##  cdb6ce236_TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n\nExercise\n\nRepeat the data manipulations above.\nCheck the number of scans in the object with length().\nNote the difference in the first line when showing the object in the console. We will get back to this idea of backend later.\n\nMass spectrometry data in Spectra objects can be thought of as a list of individual spectra, with each spectrum having a set of variables associated with it. Besides core spectra variables (such as MS level or retention time) an arbitrary number of optional variables can be assigned to a spectrum. The core spectra variables all have their own accessor method and it is guaranteed that a value is returned by it (or NA if the information is not available). The core variables and their data type are (alphabetically ordered):\n\n\nacquisitionNum integer(1): the index of acquisition of a spectrum during a MS run.\n\ncentroided logical(1): whether the spectrum is in profile or centroid mode.\n\ncollisionEnergy numeric(1): collision energy used to create an MSn spectrum.\n\ndataOrigin character(1): the origin of the spectrum‚Äôs data, e.g.¬†the mzML file from which it was read.\n\ndataStorage character(1): the (current) storage location of the spectrum data. This value depends on the backend used to handle and provide the data. For an in-memory backend like the MsBackendMemory this will be \"&lt;memory&gt;\", for an on-disk backend such as the MsBackendHdf5Peaks it will be the name of the HDF5 file where the spectrum‚Äôs peak data is stored.\n\nintensity numeric: intensity values for the spectrum‚Äôs peaks.\n\nisolationWindowLowerMz numeric(1): lower m/z for the isolation window in which the (MSn) spectrum was measured.\n\nisolationWindowTargetMz numeric(1): the target m/z for the isolation window in which the (MSn) spectrum was measured.\n\nisolationWindowUpperMz numeric(1): upper m/z for the isolation window in which the (MSn) spectrum was measured.\n\nmsLevel integer(1): the MS level of the spectrum.\n\nmz numeric: the m/z values for the spectrum‚Äôs peaks.\n\npolarity integer(1): the polarity of the spectrum (0 and 1 representing negative and positive polarity, respectively).\n\nprecScanNum integer(1): the scan (acquisition) number of the precursor for an MSn spectrum.\n\nprecursorCharge integer(1): the charge of the precursor of an MSn spectrum.\n\nprecursorIntensity numeric(1): the intensity of the precursor of an MSn spectrum.\n\nprecursorMz numeric(1): the m/z of the precursor of an MSn spectrum.\n\nrtime numeric(1): the retention time of a spectrum.\n\nscanIndex integer(1): the index of a spectrum within a (raw) file.\n\nsmoothed logical(1): whether the spectrum was smoothed.\n\nFor details on the individual variables and their getter/setter function see the help for Spectra (?Spectra). Also note that these variables are suggested, but not required to characterize a spectrum. Also, some only make sense for MSn, but not for MS1 spectra.\nIn addition to the core spectra variables it is also possible to add additional spectra variables to a Spectra object. As an example we add below a spectra variable representing the retention times in minutes to the object. This information can then be extracted again using the $ notation (similar to accessing a column in a data.frame, i.e., $ and the name of the spectra variable).\n\nsp$rtime_minute &lt;- rtime(sp) / 60\nsp$rtime_minute |&gt; head()\n##  [1] 0.00764000 0.01620833 0.03087333 0.04570667 0.06020667 0.07487500\n\nExercise\n\nExtract a set of spectra variables using the accessor (for example msLevel(.)) or using the $ notation (for example .$msLevel).\nHow many MS level are there, and how many scans of each level?\nExtract the index of the MS2 spectrum with the highest base peak intensity.\nAre the data centroided or in profile mode?\nPick a spectrum of each level and visually check whether it is centroided or in profile mode. You can use the plotSpectra() function to visualise peaks and set the m/z range with the xlim arguments.\nExercise\nUsing the first raw data file starting with MS3TMT10, answer the following questions:\n\nHow many spectra are there in that file?\nHow many MS levels, and how many spectra per MS level?\nWhat is the index of the MS2 spectrum with the highest precursor intensity?\nPlot one spectrum of each level. Are they centroided or in profile mode?\n\nThese objects and their manipulations are not limited to single files or samples. Below we load data from two mzML files. The MS data from both files in the Spectra is organized linearly (first all spectra from the first file and then from the second). The dataOrigin function can be used to identify spectra from the different data files.\n\nfls &lt;- dir(system.file(\"sciex\", package = \"msdata\"), full.names = TRUE)\nsp_sciex &lt;- Spectra(fls)\ntable(dataOrigin(sp_sciex))\n##  \n##  /usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML \n##                                                                          931 \n##  /usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_3_105-134.mzML \n##                                                                          931\n\n\n2.1.3 Backends\nBackends allow to use different backends to store mass spectrometry data while providing via the Spectra class a unified interface to use that data. With the setBackend function it is possible to change between different backends and hence different data representations. The Spectra package defines a set of example backends but any object extending the base MsBackend class could be used instead. The default backends are:\n\n\nMsBackendMzR: this backend keeps only general spectra variables in memory and relies on the mzR package to read mass peaks (m/z and intensity values) from the original MS files on-demand.\n\n\nsp_sciex\n##  MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend:\n##         msLevel     rtime scanIndex\n##       &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1            1     0.280         1\n##  2            1     0.559         2\n##  3            1     0.838         3\n##  4            1     1.117         4\n##  5            1     1.396         5\n##  ...        ...       ...       ...\n##  1858         1   258.636       927\n##  1859         1   258.915       928\n##  1860         1   259.194       929\n##  1861         1   259.473       930\n##  1862         1   259.752       931\n##   ... 33 more variables/columns.\n##  \n##  file(s):\n##  20171016_POOL_POS_1_105-134.mzML\n##  20171016_POOL_POS_3_105-134.mzML\n\n\n\nMsBackendMemory and MsBackendDataFrame: the full mass spectrometry data is stored (in-memory) within the object. Keeping the data in memory guarantees high performance but has also, depending on the number of mass peaks in each spectrum, a much higher memory footprint.\n\n\nsetBackend(sp_sciex, MsBackendMemory())\n##  MSn data (Spectra) with 1862 spectra in a MsBackendMemory backend:\n##         msLevel     rtime scanIndex\n##       &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1            1     0.280         1\n##  2            1     0.559         2\n##  3            1     0.838         3\n##  4            1     1.117         4\n##  5            1     1.396         5\n##  ...        ...       ...       ...\n##  1858         1   258.636       927\n##  1859         1   258.915       928\n##  1860         1   259.194       929\n##  1861         1   259.473       930\n##  1862         1   259.752       931\n##   ... 33 more variables/columns.\n##  Processing:\n##   Switch backend from MsBackendMzR to MsBackendMemory [Wed Nov  8 19:53:21 2023]\n\n\n\nMsBackendHdf5Peaks: similar to MsBackendMzR this backend reads peak data only on-demand from disk while all other spectra variables are kept in memory. The peak data are stored in Hdf5 files which guarantees scalability.\n\nWith the example below we load the data from a single mzML file and use a MsBackendHdf5Peaks backend for data storage. The hdf5path parameter allows us to specify the storage location of the HDF5 file.\n\nsp_hdf5 &lt;- setBackend(sp_sciex, MsBackendHdf5Peaks(), hdf5path = tempdir())\nsp_hdf5\n##  MSn data (Spectra) with 1862 spectra in a MsBackendHdf5Peaks backend:\n##         msLevel     rtime scanIndex\n##       &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1            1     0.280         1\n##  2            1     0.559         2\n##  3            1     0.838         3\n##  4            1     1.117         4\n##  5            1     1.396         5\n##  ...        ...       ...       ...\n##  1858         1   258.636       927\n##  1859         1   258.915       928\n##  1860         1   259.194       929\n##  1861         1   259.473       930\n##  1862         1   259.752       931\n##   ... 33 more variables/columns.\n##  \n##  file(s):\n##   20171016_POOL_POS_1_105-134.h5\n##   20171016_POOL_POS_3_105-134.h5\n##  Processing:\n##   Switch backend from MsBackendMzR to MsBackendHdf5Peaks [Wed Nov  8 19:53:30 2023]\ntable(sp_hdf5$dataOrigin)\n##  \n##  /usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML \n##                                                                          931 \n##  /usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_3_105-134.mzML \n##                                                                          931\ntable(sp_hdf5$dataStorage)\n##  \n##  /tmp/RtmpQlMUKy/20171016_POOL_POS_1_105-134.h5 \n##                                             931 \n##  /tmp/RtmpQlMUKy/20171016_POOL_POS_3_105-134.h5 \n##                                             931\n\nAll of the above mentioned backends support changing all of their their spectra variables, except the MsBackendMzR that does not support changing m/z or intensity values for the mass peaks.\nNext to these default backends there are a set of other backend implementations provided by additional R packages. The MsBackendSql for example allows to store (and retrieve) all MS data in (from) an SQL database guaranteeing thus a minimal memory footprint.\nOther backends focus on specific file formats such as MsBackendMgf for files in mgf file format or on specific acquisitions such as MsBackendTimsTof or provide access to certain MS data resources such as the MsBackendMassbank. Additional backends are being developed to address specific needs or technologies, while remaining compliant with the Spectra interface.\nIf you would like to learn more about how the raw MS formats are handled by Spectra via the mzR package, check out the @ref(sec-raw2) section in the annex.\nSee also Spectra backends for more information on different backends, their properties and advantages/disadvantages."
  },
  {
    "objectID": "pages/raw-ms-data.html#visualisation-of-raw-ms-data",
    "href": "pages/raw-ms-data.html#visualisation-of-raw-ms-data",
    "title": "2¬† Raw MS data",
    "section": "\n2.2 Visualisation of raw MS data",
    "text": "2.2 Visualisation of raw MS data\nThe importance of flexible access to specialised data becomes visible in the figure below (taken from the RforProteomics visualisation vignette). Not only can we access specific data and understand/visualise them, but we can transverse all the data and extract/visualise/understand structured slices of data.\nThe figure below shows an illustration of how mass spectrometry works:\n\nThe chromatogram at the top displays the total ion current along the retention time. The vertical line identifies one scan in particular at retention time 1800.68 seconds (the 2807th scan).\nThe spectra on the second line represent the full MS1 spectrum marked by the red line. The vertical lines identify the 10 precursor ions that where selected for MS2 analysis. The zoomed in on the right shows one specific precursor peak.\nThe MS2 spectra displayed along the two rows at the bottom are those resulting from the fragmentation of the 10 precursor peaks identified by the vertical bars above.\n\n\n\n\n\n\n\n\n\nWe are going to reproduce the figure above through a set of exercices.\n\nThe chromatogram can be created by extracting the totIonCurrent and rtime variables for all MS1 spectra. Annotate the spectrum of interest.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\nwith(spectraData(filterMsLevel(sp, 1)),\n     plot(rtime, totIonCurrent, type = \"l\"))\nabline(v = rtime(sp)[2807], col = \"red\")\n\n\n\n\n\n\n\n\n\n\n\nThe filterPrecursorScan() function can be used to retain a set parent (MS1) and children scans (MS2), as defined by an acquisition number. Use it to extract the MS1 scan of interest and all its MS2 children.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\nms_2 &lt;- filterPrecursorScan(sp, 2807)\nms_2\n##  MSn data (Spectra) with 11 spectra in a MsBackendMzR backend:\n##       msLevel     rtime scanIndex\n##     &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1          1   1800.68      2807\n##  2          2   1801.26      2808\n##  3          2   1801.92      2809\n##  4          2   1802.20      2810\n##  5          2   1802.48      2811\n##  6          2   1802.77      2812\n##  7          2   1803.05      2813\n##  8          2   1803.34      2814\n##  9          2   1803.64      2815\n##  10         2   1803.93      2816\n##  11         2   1804.21      2817\n##   ... 34 more variables/columns.\n##  \n##  file(s):\n##  cdb6ce236_TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##  Processing:\n##   Filter: select parent/children scans for 2807 [Wed Nov  8 19:53:30 2023]\n\n\n\n\n\nPlot the MS1 spectrum of interest and highlight all the peaks that will be selected for MS2 analysis.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\nplotSpectra(sp[2807], xlim = c(400, 1000))\nabline(v = precursorMz(ms_2)[-1], col = \"grey\")\nabline(v = precursorMz(ms_2)[2], col = \"red\")\n\n\n\n\n\n\n\n\n\n\n\nZoom in mz values 521.1 and 522.5 to reveal the isotopic envelope of that peak.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\nplotSpectra(sp[2807], xlim = c(521.2, 522.5), type = \"l\")\nabline(v = precursorMz(ms_2)[2], col = \"red\")\n\n\n\n\n\n\n\n\n\n\n\nThe plotSpectra() function is used to plot all 10 MS2 spectra in one call.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\nplotSpectra(ms_2[-1])\n\n\n\n\n\n\n\n\n\n\nIt is possible to label the peaks with the plotSpectra() function. The labels argument is either a character of appropriate length (i.e.¬†with a label for each peak) or, as illustrated below, a function that computes the labels.\n\nmzLabel &lt;- function(z) {\n    z &lt;- peaksData(z)[[1L]]\n    lbls &lt;- format(z[, \"mz\"], digits = 4)\n    lbls[z[, \"intensity\"] &lt; 1e5] &lt;- \"\"\n    lbls\n}\n\nplotSpectra(ms_2[7],\n            xlim = c(126, 132),\n            labels = mzLabel,\n            labelSrt = -30, labelPos = 2,\n            labelOffset = 0.1)\n\n\n\n\n\n\n\nSpectra can also be compared either by overlay or mirror plotting using the plotSpectraOverlay() and plotSpectraMirror() functions.\n\nFilter MS2 level spectra and find any 2 MS2 spectra that have matching precursor peaks based on the precursor m/z values.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\nsp2 &lt;- filterMsLevel(sp, 2L)\nanyDuplicated(precursorMz(filterMsLevel(sp, 2)))\n##  [1] 37\ni &lt;- which(precursorMz(sp2) == precursorMz(sp2)[37])\nsp2i &lt;- sp2[i]\n\n\n\n\n\nVisualise the matching pair using the plotSpectraOverlay() and plotSpectraMirror() functions.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\nplotSpectraOverlay(sp2i, col = c(\"red\", \"steelblue\"))\n\n\n\n\n\n\n\n\nplotSpectraMirror(sp2i[1], sp2i[2])\n\n\n\n\n\n\n\n\n\n\nIt is also possible to explore raw data interactively with the SpectraVis package:\n\nThe browseSpectra() function opens a simple shiny application that allows to browse through the individual scans of a Spectra object.\nThe plotlySpectra() function displays a single spectrum using plotly allowing to explore (zooming, panning) the spectrum interactively.\nTest the SpectraVis function on some the Spectra objects produce above."
  },
  {
    "objectID": "pages/raw-ms-data.html#raw-data-processing-and-manipulation",
    "href": "pages/raw-ms-data.html#raw-data-processing-and-manipulation",
    "title": "2¬† Raw MS data",
    "section": "\n2.3 Raw data processing and manipulation",
    "text": "2.3 Raw data processing and manipulation\nApart from classical subsetting operations such as [ and split, a set of filter functions are defined for Spectra objects that filter/reduce the number of spectra within the object (for detailed help please see the ?Spectra help):\n\n\nfilterAcquisitionNum: retains spectra with certain acquisition numbers.\n\nfilterDataOrigin: subsets to spectra from specific origins.\n\nfilterDataStorage: subsets to spectra from certain data storage files.\n\nfilterEmptySpectra: removes spectra without mass peaks.\n\nfilterMzRange: subsets spectra keeping only peaks with an m/z within the provided m/z range.\n\nfilterIsolationWindow: keeps spectra with the provided mz in their isolation window (m/z range).\n\nfilterMsLevel: filters by MS level.\n\nfilterPolarity: filters by polarity.\n\nfilterPrecursorIsotopes: identifies precursor ions (from fragment spectra) that could represent isotopes of the same molecule. For each of these spectra groups only the spectrum of the monoisotopic precursor ion is returned. MS1 spectra are returned without filtering.\n\nfilterPrecursorMaxIntensity: filters spectra keeping, for groups of spectra with similar precursor m/z, the one spectrum with the highest precursor intensity. All MS1 spectra are returned without filtering.\n\nfilterPrecursorMzRange: retains (MSn) spectra with a precursor m/z within the provided m/z range.\n\nfilterPrecursorMzValues: retains (MSn) spectra with precursor m/z value matching the provided value(s) considering also a tolerance and ppm.\n\nfilterPrecursorCharge: retains (MSn) spectra with speified precursor charge(s).\n\nfilterPrecursorScan: retains (parent and children) scans of an acquisition number.\n\nfilterRt: filters based on retention time range.\n\nIn addition to these, there is also a set of filter functions that operate on the peak data, filtering and modifying the number of peaks of each spectrum within a Spectra:\n\ncombinePeaks: groups peaks within each spectrum based on similarity of their m/z values and combines these into a single peak per peak group.\ndeisotopeSpectra: deisotopes each individual spectrum keeping only the monoisotopic peak for peaks groups of potential isotopologues.\nfilterIntensity: filter each spectrum keeping only peaks with intensities meeting certain criteria.\nfilterMzRange: subsets peaks data within each spectrum keeping only peaks with their m/z values within the specified m/z range.\nfilterPrecursorPeaks: removes peaks with either an m/z value matching the precursor m/z of the respective spectrum (with parameter mz = \"==\") or peaks with an m/z value larger or equal to the precursor m/z (with parameter mz = \"&gt;=\").\nfilterMzValues: subsets peaks within each spectrum keeping or removing (all) peaks matching provided m/z value(s) (given parameters ppm and tolerance).\nreduceSpectra: filters individual spectra keeping only the largest peak for groups of peaks with similar m/z values.\nUsing the sp_sciex data, select all spectra measured in the second mzML file and subsequently filter them to retain spectra measured between 175 and 189 seconds in the measurement run.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nfls &lt;- unique(dataOrigin(sp_sciex))\nfls\n##  [1] \"/usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\"\n##  [2] \"/usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_3_105-134.mzML\"\nfile_2 &lt;- filterDataOrigin(sp_sciex, dataOrigin = fls[2])\nlength(file_2)\n##  [1] 931\nsps_sub &lt;- filterRt(file_2, rt = c(175, 189))\nlength(sps_sub)\n##  [1] 50\n\n\nsp_sciex |&gt;\n    filterDataOrigin(fls[2]) |&gt;\n    filterRt(c(175, 189))\n##  MSn data (Spectra) with 50 spectra in a MsBackendMzR backend:\n##        msLevel     rtime scanIndex\n##      &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1           1   175.212       628\n##  2           1   175.491       629\n##  3           1   175.770       630\n##  4           1   176.049       631\n##  5           1   176.328       632\n##  ...       ...       ...       ...\n##  46          1   187.768       673\n##  47          1   188.047       674\n##  48          1   188.326       675\n##  49          1   188.605       676\n##  50          1   188.884       677\n##   ... 33 more variables/columns.\n##  \n##  file(s):\n##  20171016_POOL_POS_3_105-134.mzML\n##  Processing:\n##   Filter: select data origin(s) /usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_3_105-134.mzML [Wed Nov  8 19:53:32 2023]\n##   Filter: select retention time [175..189] on MS level(s) 1 [Wed Nov  8 19:53:32 2023]\n\n\n\n\nAs an example of data processing, we use below the pickPeaks() function. This function allows to convert profile mode MS data to centroid mode data (a process also referred to as centroiding).\n\nplotSpectra(sp[2807], xlim = c(521.2, 522.5))\n\n\n\n\n\n\n\nCentroiding reduces the profile mode MS data to a representative single mass peak per ion.\n\npickPeaks(sp[2807]) |&gt;\n    filterIntensity(1e7) |&gt;\n    plotSpectra(xlim = c(521.2, 522.5))"
  },
  {
    "objectID": "pages/raw-ms-data.html#a-note-on-efficiency",
    "href": "pages/raw-ms-data.html#a-note-on-efficiency",
    "title": "2¬† Raw MS data",
    "section": "\n2.4 A note on efficiency",
    "text": "2.4 A note on efficiency\n\n2.4.1 Backends\nThe figure below (taken from (Gatto, Gibb, and Rainer 2020)) illustrates the respective advantages of storing data in memory or on disk. The benchmarking was done for the MSnbase package but also applies to the Spectra backends.\n\n\n\n\n(a) Reading time (triplicates, in seconds) and (b) data size in memory (in MB) to read/store 1, 5, and 10 files containing 1431 MS1 (on-disk only) and 6103 MS2 (on-disk and in-memory) spectra. (c) Filtering benchmark assessed over 10 interactions on in-memory and on-disk data containing 6103 MS2 spectra. (d) Access time to spectra for the in-memory (left) and on-disk (right) backends for 1, 10, 100 1000, 5000, and all 6103 spectra. Benchmarks were performed on a Dell XPS laptop with an Intel i5-8250U processor 1.60 GHz (4 cores, 8 threads), 7.5 GB RAM running Ubuntu 18.04.4 LTS 64-bit, and an SSD drive. The data used for the benchmarking are a TMT 4-plex experiment acquired on a LTQ Orbitrap Velos (Thermo Fisher Scientific) available in the msdata package.\n\n\n\n\n2.4.2 Parallel processing\nMost functions on Spectra support (and use) parallel processing out of the box. Peak data access and manipulation methods perform by default parallel processing on a per-file basis (i.e.¬†using the dataStorage variable as splitting factor). Spectra uses BiocParallel for parallel processing and all functions use the default registered parallel processing setup of that package.\n\n2.4.3 Lazy evaluation\nData manipulations on Spectra objects are not immediately applied to the peak data. They are added to a so called processing queue which is applied each time peak data is accessed (with the peaksData, mz or intensity functions). Thanks to this processing queue data manipulation operations are also possible for read-only backends (e.g.¬†mzML-file based backends or database-based backends). The information about the number of such processing steps can be seen below (next to Lazy evaluation queue).\n\nmin(intensity(sp_sciex[1]))\n##  [1] 0\nsp_sciex &lt;- filterIntensity(sp_sciex, intensity = c(10, Inf))\nsp_sciex ## Note the lazy evaluation queue\n##  MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend:\n##         msLevel     rtime scanIndex\n##       &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1            1     0.280         1\n##  2            1     0.559         2\n##  3            1     0.838         3\n##  4            1     1.117         4\n##  5            1     1.396         5\n##  ...        ...       ...       ...\n##  1858         1   258.636       927\n##  1859         1   258.915       928\n##  1860         1   259.194       929\n##  1861         1   259.473       930\n##  1862         1   259.752       931\n##   ... 33 more variables/columns.\n##  \n##  file(s):\n##  20171016_POOL_POS_1_105-134.mzML\n##  20171016_POOL_POS_3_105-134.mzML\n##  Lazy evaluation queue: 1 processing step(s)\n##  Processing:\n##   Remove peaks with intensities outside [10, Inf] in spectra of MS level(s) 1. [Wed Nov  8 19:53:33 2023]\nmin(intensity(sp_sciex[1]))\n##  [1] 412\nsp_sciex@processingQueue\n##  [[1]]\n##  Object of class \"ProcessingStep\"\n##   Function: user-provided function\n##   Arguments:\n##    o intensity = 10Inf\n##    o msLevel = 1\n\nThrough this lazy evaluation system it is also possible to undo data manipulations:\n\nsp_sciex &lt;- reset(sp_sciex)\nsp_sciex@processingQueue\n##  list()\nmin(intensity(sp_sciex[1]))\n##  [1] 0\n\nMore information on this lazy evaluation concept implemented in Spectra is provided in the Spectra backends vignette."
  },
  {
    "objectID": "pages/raw-ms-data.html#footnotes",
    "href": "pages/raw-ms-data.html#footnotes",
    "title": "2¬† Raw MS data",
    "section": "",
    "text": "As defined in the Bioconductor S4Vectors package.‚Ü©Ô∏é"
  }
]