[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R for Mass Spectrometry",
    "section": "",
    "text": "Welcome\nThe aim of the R for Mass Spectrometry initiative is to provide efficient, thoroughly documented, tested and flexible R software for the analysis and interpretation of high throughput mass spectrometry assays, including proteomics and metabolomics experiments. The project formalises the longtime collaborative development efforts of its core members under the RforMassSpectrometry organisation to facilitate dissemination and accessibility of their work.\nThis material introduces participants to the analysis and exploration of mass spectrometry (MS) based proteomics data using R and Bioconductor. The course will cover all levels of MS data, from raw data to identification and quantitation data, up to the statistical interpretation of a typical shotgun MS experiment and will focus on hands-on tutorials. At the end of this course, the participants will be able to manipulate MS data in R and use existing packages for their exploratory and statistical proteomics data analysis.\nA Docker image built from this repository is available here:\nüëâ ghcr.io/js2264/r4ms üê≥\nAn RStudio Server instance can be initiated from the Docker image as follows:\nbash\n\ndocker run \\\n    --volume &lt;local_folder&gt;:&lt;destination_folder&gt; \\\n    -e PASSWORD=OHCA \\\n    -p 8787:8787 \\\n    ghcr.io/js2264/r4ms:devel\nThe initiated RStudio Server instance will be available at https://localhost:8787."
  },
  {
    "objectID": "index.html#targeted-audience-and-assumed-background",
    "href": "index.html#targeted-audience-and-assumed-background",
    "title": "R for Mass Spectrometry",
    "section": "Targeted audience and assumed background",
    "text": "Targeted audience and assumed background\nThe course material is targeted to either proteomics practitioners or data analysts/bioinformaticians that would like to learn how to use R and Bioconductor to analyse proteomics data. Familiarity with MS or proteomics in general is desirable, but not essential as we will walk through and describe a typical MS data as part of learning about the tools. For approachable introductions to sample preparation, mass spectrometry, data interpretation and analysis, readers are redirected to:\n\n\nA beginner‚Äôs guide to mass spectrometry‚Äìbased proteomics (Sinha and Mann 2020)\n\n\nThe ABC‚Äôs (and XYZ‚Äôs) of peptide sequencing (Steen and Mann 2004)\n\n\nHow do shotgun proteomics algorithms identify proteins? (Marcotte 2007)\n\n\nAn Introduction to Mass Spectrometry-Based Proteomics (Shuken 2023)\n\n\nA working knowledge of R (R syntax, commonly used functions, basic data structures such as data frames, vectors, matrices, ‚Ä¶ and their manipulation) is required. Familiarity with other Bioconductor omics data classes and the tidyverse syntax is useful, but not necessary."
  },
  {
    "objectID": "index.html#setup",
    "href": "index.html#setup",
    "title": "R for Mass Spectrometry",
    "section": "Setup",
    "text": "Setup\nThis material uses the latest version of the R for Mass Spectrometry package and their dependencies. It might thus be possible that even the latest Bioconductor stable version isn‚Äôt recent enough.\nTo install all the necessary package, please use the latest release of R and execute:\n\nif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\nBiocManager::install(\"tidyverse\")\nBiocManager::install(\"factoextra\")\nBiocManager::install(\"msdata\")\nBiocManager::install(\"mzR\")\nBiocManager::install(\"rhdf5\")\nBiocManager::install(\"rpx\")\nBiocManager::install(\"MsCoreUtils\")\nBiocManager::install(\"QFeatures\")\nBiocManager::install(\"Spectra\")\nBiocManager::install(\"ProtGenerics\")\nBiocManager::install(\"PSMatch\")\nBiocManager::install(\"pheatmap\")\nBiocManager::install(\"limma\")\nBiocManager::install(\"MSnID\")\n\nFollow the instructions in this script to install the packages and download some of the data used in the following chapters. All software versions used to generate this document are recoded at the end of the book in @ref(sec-si)."
  },
  {
    "objectID": "index.html#acknowledgments",
    "href": "index.html#acknowledgments",
    "title": "R for Mass Spectrometry",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nThank you to Charlotte Soneson for fixing many typos in a previous version of this book."
  },
  {
    "objectID": "index.html#license",
    "href": "index.html#license",
    "title": "R for Mass Spectrometry",
    "section": "License",
    "text": "License\nThis material is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. You are free to share (copy and redistribute the material in any medium or format) and adapt (remix, transform, and build upon the material) for any purpose, even commercially, as long as you give appropriate credit and distribute your contributions under the same license as the original."
  },
  {
    "objectID": "pages/introduction.html#how-does-mass-spectrometry-work",
    "href": "pages/introduction.html#how-does-mass-spectrometry-work",
    "title": "1¬† Introduction",
    "section": "\n1.1 How does mass spectrometry work?",
    "text": "1.1 How does mass spectrometry work?\nMass spectrometry (MS) is a technology that separates charged molecules (ions) based on their mass to charge ratio (M/Z). It is often coupled to chromatography (liquid LC, but can also be gas-based GC). The time an analyte takes to elute from the chromatography column is the retention time.\n\n\n\n\nA chromatogram, illustrating the total amount of analytes over the retention time.\n\n\n\nAn mass spectrometer is composed of three components:\n\nThe source, that ionises the molecules: examples are Matrix-assisted laser desorption/ionisation (MALDI) or electrospray ionisation. (ESI)\nThe analyser, that separates the ions: Time of flight (TOF) or Orbitrap.\nThe detector that quantifies the ions.\n\nWhen using mass spectrometry for proteomics, the proteins are first digested with a protease such as trypsin. In mass shotgun proteomics, the analytes assayed in the mass spectrometer are peptides.\nOften, ions are subjected to more than a single MS round. After a first round of separation, the peaks in the spectra, called MS1 spectra, represent peptides. At this stage, the only information we possess about these peptides are their retention time and their mass-to-charge (we can also infer their charge by inspecting their isotopic envelope, i.e the peaks of the individual isotopes, see below), which is not enough to infer their identify (i.e.¬†their sequence).\nIn MSMS (or MS2), the settings of the mass spectrometer are set automatically to select a certain number of MS1 peaks (for example 20)1. Once a narrow M/Z range has been selected (corresponding to one high-intensity peak, a peptide, and some background noise), it is fragmented (using for example collision-induced dissociation (CID), higher energy collisional dissociation (HCD) or electron-transfer dissociation (ETD)). The fragment ions are then themselves separated in the analyser to produce a MS2 spectrum. The unique fragment ion pattern can then be used to infer the peptide sequence using de novo sequencing (when the spectrum is of high enough quality) or using a search engine such as, for example Mascot, MSGF+, ‚Ä¶, that will match the observed, experimental spectrum to theoretical spectra (see details below).\n\n\n\n\nSchematics of a mass spectrometer and two rounds of MS.\n\n\n\nThe animation below show how 25 ions different ions (i.e.¬†having different M/Z values) are separated throughout the MS analysis and are eventually detected (i.e.¬†quantified). The final frame shows the hypothetical spectrum.\n\n\n\n\nSeparation and detection of ions in a mass spectrometer.\n\n\n\nThe figures below illustrate the two rounds of MS. The spectrum on the left is an MS1 spectrum acquired after 21 minutes and 3 seconds of elution. 10 peaks, highlited by dotted vertical lines, were selected for MS2 analysis. The peak at M/Z 460.79 (488.8) is highlighted by a red (orange) vertical line on the MS1 spectrum and the fragment spectra are shown on the MS2 spectrum on the top (bottom) right figure.\n\n\n\n\nParent ions in the MS1 spectrum (left) and two sected fragment ions MS2 spectra (right)\n\n\n\nThe figures below represent the 3 dimensions of MS data: a set of spectra (M/Z and intensity) of retention time, as well as the interleaved nature of MS1 and MS2 (and there could be more levels) data.\n\n\n\n\nMS1 spectra over retention time.\n\n\n\n\n\n\n\nMS2 spectra interleaved between two MS1 spectra."
  },
  {
    "objectID": "pages/introduction.html#accessing-data",
    "href": "pages/introduction.html#accessing-data",
    "title": "1¬† Introduction",
    "section": "\n1.2 Accessing data",
    "text": "1.2 Accessing data\n\n1.2.1 From the ProteomeXchange database\nMS-based proteomics data is disseminated through the ProteomeXchange infrastructure, which centrally coordinates submission, storage and dissemination through multiple data repositories, such as the PRoteomics IDEntifications (PRIDE) database at the EBI for mass spectrometry-based experiments (including quantitative data, as opposed as the name suggests), PASSEL at the ISB for Selected Reaction Monitoring (SRM, i.e.¬†targeted) data and the MassIVE resource. These data can be downloaded within R using the rpx package.\n\nlibrary(rpx)\n\nUsing the unique PXD000001 identifier, we can retrieve the relevant metadata that will be stored in a PXDataset object. The names of the files available in this data can be retrieved with the pxfiles accessor function.\n\npx &lt;- PXDataset(\"PXD000001\")\n##  Querying ProteomeXchange for PXD000001.\npx\n##  Project PXD000001 with 11 files\n##  \n##  Resource ID BFC1 in cache in /root/.cache/R/rpx.\n##   [1] 'F063721.dat' ... [11] 'erwinia_carotovora.fasta'\n##   Use 'pxfiles(.)' to see all files.\npxfiles(px)\n##  Project PXD000001 files (11):\n##   [remote] F063721.dat\n##   [remote] F063721.dat-mztab.txt\n##   [remote] PRIDE_Exp_Complete_Ac_22134.xml.gz\n##   [remote] PRIDE_Exp_mzData_Ac_22134.xml.gz\n##   [remote] PXD000001_mztab.txt\n##   [remote] README.txt\n##   [remote] TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##   [remote] TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzXML\n##   [remote] TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzXML\n##   [remote] TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.raw\n##   ...\n\nOther metadata for the px data set:\n\npxtax(px)\n##  [1] \"Erwinia carotovora\"\npxurl(px)\n##  [1] \"ftp://ftp.pride.ebi.ac.uk/pride/data/archive/2012/03/PXD000001/generated\"\npxref(px)\n##  [1] \"Gatto L, Christoforou A; Using R and Bioconductor for proteomics data analysis., Biochim Biophys Acta, 2013 May 18, doi:10.1016/j.bbapap.2013.04.032 PMID:23692960\"\n\nData files can then be downloaded with the pxget function. Below, we retrieve the raw data file. The file is downloaded2 in the working directory and the name of the file is return by the function and stored in the mzf variable for later use 3.\n\nfn &lt;- \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\"\nmzf &lt;- pxget(px, fn)\n##  Downloading TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML file.\nmzf\n##  [1] \"/root/.cache/R/rpx/d177d1ab84_TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\"\n\n\n1.2.2 Data packages\nSome data are also distributed through dedicated packages. The msdata, for example, provides some general raw data files relevant for both proteomics and metabolomics.\n\nlibrary(msdata)\n## proteomics raw data\nproteomics()\n##  [1] \"MRM-standmix-5.mzML.gz\"                                                \n##  [2] \"MS3TMT10_01022016_32917-33481.mzML.gz\"                                 \n##  [3] \"MS3TMT11.mzML\"                                                         \n##  [4] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML.gz\"\n##  [5] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.gz\"\n## proteomics identification data\nident()\n##  [1] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\"\n## quantitative data\nquant()\n##  [1] \"cptac_a_b_peptides.txt\"\n\nMore often, such experiment packages distribute processed data; an example of such is the pRolocdata package, that offers quantitative proteomics data."
  },
  {
    "objectID": "pages/introduction.html#footnotes",
    "href": "pages/introduction.html#footnotes",
    "title": "1¬† Introduction",
    "section": "",
    "text": "Here, we will focus on data dependent acquisition (DDA), where MS1 peaks are selected. In data independent acquisition (DIA), all peaks in the MS1 spectrum are fragmented.‚Ü©Ô∏é\nIf the file is already available, it is not downloaded a second time.‚Ü©Ô∏é\nThis and other files are also availabel in the msdata package, described below‚Ü©Ô∏é"
  },
  {
    "objectID": "pages/raw-ms-data.html",
    "href": "pages/raw-ms-data.html",
    "title": "2¬† Raw MS data",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "pages/raw-ms-data.html#what-is-raw-data-in-r",
    "href": "pages/raw-ms-data.html#what-is-raw-data-in-r",
    "title": "2¬† Raw MS data",
    "section": "\n2.1 What is raw data in R",
    "text": "2.1 What is raw data in R\nWhen we manipulate complex data, we need a way to abstract it.\nThe abstraction saves us from having to know about all the details of that data and its associated metadata. In R, we think of MS data as illustrated on the figure below (taken from (Gatto, Gibb, and Rainer 2020)): a metadata table and a set of raw spectra. This allows to rely on a few easy-to-remember conventions to make mundane and repetitive tasks trivial and be able to complete more complex things easily. Abstractions provide a smoother approach to handle complex data using common patterns.\n\n\n\n\nSchematic representation of what is referred to by raw data: a collection of mass spectra and a table containing spectrum-level annotations along the lines. Raw data are imported from one of the many community-maintained open standards formats (mzML, mzXML, mzData or ANDI-MS/netCDF).\n\n\n\n\n2.1.1 The Spectra class\nWe are going to use the Spectra package as an abstraction to raw mass spectrometry data.\n\nlibrary(Spectra)\n\nSpectra is part of the R for Mass Spectrometry initiative. It defines the Spectra class that is used as a raw data abstraction, to manipulate MS data and metadata. The best way to learn about a data structure is to create one by hand.\nLet‚Äôs create a DataFrame1 containing MS levels, retention time, m/z and intensities for 2 spectra:\n\nspd &lt;- DataFrame(msLevel = c(1L, 2L), rtime = c(1.1, 1.2))\nspd$mz &lt;- list(c(100, 103.2, 104.3, 106.5), c(45.6, 120.4, 190.2))\nspd$intensity &lt;- list(c(200, 400, 34.2, 17), c(12.3, 15.2, 6.8))\nspd\n##  DataFrame with 2 rows and 4 columns\n##      msLevel     rtime                    mz             intensity\n##    &lt;integer&gt; &lt;numeric&gt;                &lt;list&gt;                &lt;list&gt;\n##  1         1       1.1 100.0,103.2,104.3,... 200.0,400.0, 34.2,...\n##  2         2       1.2      45.6,120.4,190.2        12.3,15.2, 6.8\n\nAnd now convert this DataFrame into a Spectra object:\n\nsp0 &lt;- Spectra(spd)\nsp0\n##  MSn data (Spectra) with 2 spectra in a MsBackendMemory backend:\n##      msLevel     rtime scanIndex\n##    &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1         1       1.1        NA\n##  2         2       1.2        NA\n##   ... 16 more variables/columns.\n\nExercise\nExplore the newly created object using:\n\n\nspectraVariables to extract all the metadata variables. Compare these to the spectra variables available from the previous example.\n\nspectraData to extract all the metadata.\n\npeaksData to extract a list containing the raw data.\n\n[ to create subsets.\n\n2.1.2 Spectra from mzML files\nLet‚Äôs now create a new object using the mzML data previously downloaded and available in the mzf file.\n\nlibrary(rpx)\nfn &lt;- \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\"\npx &lt;- PXDataset(\"PXD000001\")\n##  Loading PXD000001 from cache.\nmzf &lt;- pxget(px, fn)\n##  Loading TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML from cache.\nmzf\n##  [1] \"/root/.cache/R/rpx/d177d1ab84_TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\"\nsp &lt;- Spectra(mzf)\nsp\n##  MSn data (Spectra) with 7534 spectra in a MsBackendMzR backend:\n##         msLevel     rtime scanIndex\n##       &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1            1    0.4584         1\n##  2            1    0.9725         2\n##  3            1    1.8524         3\n##  4            1    2.7424         4\n##  5            1    3.6124         5\n##  ...        ...       ...       ...\n##  7530         2   3600.47      7530\n##  7531         2   3600.83      7531\n##  7532         2   3601.18      7532\n##  7533         2   3601.57      7533\n##  7534         2   3601.98      7534\n##   ... 33 more variables/columns.\n##  \n##  file(s):\n##  d177d1ab84_TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n\nExercise\n\nRepeat the data manipulations above.\nCheck the number of scans in the object with length().\nNote the difference in the first line when showing the object in the console. We will get back to this idea of backend later.\n\nMass spectrometry data in Spectra objects can be thought of as a list of individual spectra, with each spectrum having a set of variables associated with it. Besides core spectra variables (such as MS level or retention time) an arbitrary number of optional variables can be assigned to a spectrum. The core spectra variables all have their own accessor method and it is guaranteed that a value is returned by it (or NA if the information is not available). The core variables and their data type are (alphabetically ordered):\n\n\nacquisitionNum integer(1): the index of acquisition of a spectrum during a MS run.\n\ncentroided logical(1): whether the spectrum is in profile or centroid mode.\n\ncollisionEnergy numeric(1): collision energy used to create an MSn spectrum.\n\ndataOrigin character(1): the origin of the spectrum‚Äôs data, e.g.¬†the mzML file from which it was read.\n\ndataStorage character(1): the (current) storage location of the spectrum data. This value depends on the backend used to handle and provide the data. For an in-memory backend like the MsBackendMemory this will be \"&lt;memory&gt;\", for an on-disk backend such as the MsBackendHdf5Peaks it will be the name of the HDF5 file where the spectrum‚Äôs peak data is stored.\n\nintensity numeric: intensity values for the spectrum‚Äôs peaks.\n\nisolationWindowLowerMz numeric(1): lower m/z for the isolation window in which the (MSn) spectrum was measured.\n\nisolationWindowTargetMz numeric(1): the target m/z for the isolation window in which the (MSn) spectrum was measured.\n\nisolationWindowUpperMz numeric(1): upper m/z for the isolation window in which the (MSn) spectrum was measured.\n\nmsLevel integer(1): the MS level of the spectrum.\n\nmz numeric: the m/z values for the spectrum‚Äôs peaks.\n\npolarity integer(1): the polarity of the spectrum (0 and 1 representing negative and positive polarity, respectively).\n\nprecScanNum integer(1): the scan (acquisition) number of the precursor for an MSn spectrum.\n\nprecursorCharge integer(1): the charge of the precursor of an MSn spectrum.\n\nprecursorIntensity numeric(1): the intensity of the precursor of an MSn spectrum.\n\nprecursorMz numeric(1): the m/z of the precursor of an MSn spectrum.\n\nrtime numeric(1): the retention time of a spectrum.\n\nscanIndex integer(1): the index of a spectrum within a (raw) file.\n\nsmoothed logical(1): whether the spectrum was smoothed.\n\nFor details on the individual variables and their getter/setter function see the help for Spectra (?Spectra). Also note that these variables are suggested, but not required to characterize a spectrum. Also, some only make sense for MSn, but not for MS1 spectra.\nIn addition to the core spectra variables it is also possible to add additional spectra variables to a Spectra object. As an example we add below a spectra variable representing the retention times in minutes to the object. This information can then be extracted again using the $ notation (similar to accessing a column in a data.frame, i.e., $ and the name of the spectra variable).\n\nsp$rtime_minute &lt;- rtime(sp) / 60\nsp$rtime_minute |&gt; head()\n##  [1] 0.00764000 0.01620833 0.03087333 0.04570667 0.06020667 0.07487500\n\nExercise\n\nExtract a set of spectra variables using the accessor (for example msLevel(.)) or using the $ notation (for example .$msLevel).\nHow many MS level are there, and how many scans of each level?\nExtract the index of the MS2 spectrum with the highest base peak intensity.\nAre the data centroided or in profile mode?\nPick a spectrum of each level and visually check whether it is centroided or in profile mode. You can use the plotSpectra() function to visualise peaks and set the m/z range with the xlim arguments.\nExercise\nUsing the first raw data file starting with MS3TMT10, answer the following questions:\n\nHow many spectra are there in that file?\nHow many MS levels, and how many spectra per MS level?\nWhat is the index of the MS2 spectrum with the highest precursor intensity?\nPlot one spectrum of each level. Are they centroided or in profile mode?\n\nThese objects and their manipulations are not limited to single files or samples. Below we load data from two mzML files. The MS data from both files in the Spectra is organized linearly (first all spectra from the first file and then from the second). The dataOrigin function can be used to identify spectra from the different data files.\n\nfls &lt;- dir(system.file(\"sciex\", package = \"msdata\"), full.names = TRUE)\nsp_sciex &lt;- Spectra(fls)\ntable(dataOrigin(sp_sciex))\n##  \n##  /usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML \n##                                                                          931 \n##  /usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_3_105-134.mzML \n##                                                                          931\n\n\n2.1.3 Backends\nBackends allow to use different backends to store mass spectrometry data while providing via the Spectra class a unified interface to use that data. With the setBackend function it is possible to change between different backends and hence different data representations. The Spectra package defines a set of example backends but any object extending the base MsBackend class could be used instead. The default backends are:\n\n\nMsBackendMzR: this backend keeps only general spectra variables in memory and relies on the mzR package to read mass peaks (m/z and intensity values) from the original MS files on-demand.\n\n\nsp_sciex\n##  MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend:\n##         msLevel     rtime scanIndex\n##       &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1            1     0.280         1\n##  2            1     0.559         2\n##  3            1     0.838         3\n##  4            1     1.117         4\n##  5            1     1.396         5\n##  ...        ...       ...       ...\n##  1858         1   258.636       927\n##  1859         1   258.915       928\n##  1860         1   259.194       929\n##  1861         1   259.473       930\n##  1862         1   259.752       931\n##   ... 33 more variables/columns.\n##  \n##  file(s):\n##  20171016_POOL_POS_1_105-134.mzML\n##  20171016_POOL_POS_3_105-134.mzML\n\n\n\nMsBackendMemory and MsBackendDataFrame: the full mass spectrometry data is stored (in-memory) within the object. Keeping the data in memory guarantees high performance but has also, depending on the number of mass peaks in each spectrum, a much higher memory footprint.\n\n\nsetBackend(sp_sciex, MsBackendMemory())\n##  MSn data (Spectra) with 1862 spectra in a MsBackendMemory backend:\n##         msLevel     rtime scanIndex\n##       &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1            1     0.280         1\n##  2            1     0.559         2\n##  3            1     0.838         3\n##  4            1     1.117         4\n##  5            1     1.396         5\n##  ...        ...       ...       ...\n##  1858         1   258.636       927\n##  1859         1   258.915       928\n##  1860         1   259.194       929\n##  1861         1   259.473       930\n##  1862         1   259.752       931\n##   ... 33 more variables/columns.\n##  Processing:\n##   Switch backend from MsBackendMzR to MsBackendMemory [Tue Dec  5 16:30:06 2023]\n\n\n\nMsBackendHdf5Peaks: similar to MsBackendMzR this backend reads peak data only on-demand from disk while all other spectra variables are kept in memory. The peak data are stored in Hdf5 files which guarantees scalability.\n\nWith the example below we load the data from a single mzML file and use a MsBackendHdf5Peaks backend for data storage. The hdf5path parameter allows us to specify the storage location of the HDF5 file.\n\nsp_hdf5 &lt;- setBackend(sp_sciex, MsBackendHdf5Peaks(), hdf5path = tempdir())\nsp_hdf5\n##  MSn data (Spectra) with 1862 spectra in a MsBackendHdf5Peaks backend:\n##         msLevel     rtime scanIndex\n##       &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1            1     0.280         1\n##  2            1     0.559         2\n##  3            1     0.838         3\n##  4            1     1.117         4\n##  5            1     1.396         5\n##  ...        ...       ...       ...\n##  1858         1   258.636       927\n##  1859         1   258.915       928\n##  1860         1   259.194       929\n##  1861         1   259.473       930\n##  1862         1   259.752       931\n##   ... 33 more variables/columns.\n##  \n##  file(s):\n##   20171016_POOL_POS_1_105-134.h5\n##   20171016_POOL_POS_3_105-134.h5\n##  Processing:\n##   Switch backend from MsBackendMzR to MsBackendHdf5Peaks [Tue Dec  5 16:30:11 2023]\ntable(sp_hdf5$dataOrigin)\n##  \n##  /usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML \n##                                                                          931 \n##  /usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_3_105-134.mzML \n##                                                                          931\ntable(sp_hdf5$dataStorage)\n##  \n##  /tmp/Rtmp2n7Wnh/20171016_POOL_POS_1_105-134.h5 \n##                                             931 \n##  /tmp/Rtmp2n7Wnh/20171016_POOL_POS_3_105-134.h5 \n##                                             931\n\nAll of the above mentioned backends support changing all of their their spectra variables, except the MsBackendMzR that does not support changing m/z or intensity values for the mass peaks.\nNext to these default backends there are a set of other backend implementations provided by additional R packages. The MsBackendSql for example allows to store (and retrieve) all MS data in (from) an SQL database guaranteeing thus a minimal memory footprint.\nOther backends focus on specific file formats such as MsBackendMgf for files in mgf file format or on specific acquisitions such as MsBackendTimsTof or provide access to certain MS data resources such as the MsBackendMassbank. Additional backends are being developed to address specific needs or technologies, while remaining compliant with the Spectra interface.\nIf you would like to learn more about how the raw MS formats are handled by Spectra via the mzR package, check out the @ref(sec-raw2) section in the annex.\nSee also Spectra backends for more information on different backends, their properties and advantages/disadvantages."
  },
  {
    "objectID": "pages/raw-ms-data.html#visualisation-of-raw-ms-data",
    "href": "pages/raw-ms-data.html#visualisation-of-raw-ms-data",
    "title": "2¬† Raw MS data",
    "section": "\n2.2 Visualisation of raw MS data",
    "text": "2.2 Visualisation of raw MS data\nThe importance of flexible access to specialised data becomes visible in the figure below (taken from the RforProteomics visualisation vignette). Not only can we access specific data and understand/visualise them, but we can transverse all the data and extract/visualise/understand structured slices of data.\nThe figure below shows an illustration of how mass spectrometry works:\n\nThe chromatogram at the top displays the total ion current along the retention time. The vertical line identifies one scan in particular at retention time 1800.68 seconds (the 2807th scan).\nThe spectra on the second line represent the full MS1 spectrum marked by the red line. The vertical lines identify the 10 precursor ions that where selected for MS2 analysis. The zoomed in on the right shows one specific precursor peak.\nThe MS2 spectra displayed along the two rows at the bottom are those resulting from the fragmentation of the 10 precursor peaks identified by the vertical bars above.\n\n\n\n\n\n\n\n\n\nWe are going to reproduce the figure above through a set of exercices.\n\nThe chromatogram can be created by extracting the totIonCurrent and rtime variables for all MS1 spectra. Annotate the spectrum of interest.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nwith(spectraData(filterMsLevel(sp, 1)),\n     plot(rtime, totIonCurrent, type = \"l\"))\nabline(v = rtime(sp)[2807], col = \"red\")\n\n\n\n\n\n\n\n\n\n\n\nThe filterPrecursorScan() function can be used to retain a set parent (MS1) and children scans (MS2), as defined by an acquisition number. Use it to extract the MS1 scan of interest and all its MS2 children.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nms_2 &lt;- filterPrecursorScan(sp, 2807)\nms_2\n##  MSn data (Spectra) with 11 spectra in a MsBackendMzR backend:\n##       msLevel     rtime scanIndex\n##     &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1          1   1800.68      2807\n##  2          2   1801.26      2808\n##  3          2   1801.92      2809\n##  4          2   1802.20      2810\n##  5          2   1802.48      2811\n##  6          2   1802.77      2812\n##  7          2   1803.05      2813\n##  8          2   1803.34      2814\n##  9          2   1803.64      2815\n##  10         2   1803.93      2816\n##  11         2   1804.21      2817\n##   ... 34 more variables/columns.\n##  \n##  file(s):\n##  d177d1ab84_TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##  Processing:\n##   Filter: select parent/children scans for 2807 [Tue Dec  5 16:30:11 2023]\n\n\n\n\n\nPlot the MS1 spectrum of interest and highlight all the peaks that will be selected for MS2 analysis.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nplotSpectra(sp[2807], xlim = c(400, 1000))\nabline(v = precursorMz(ms_2)[-1], col = \"grey\")\nabline(v = precursorMz(ms_2)[2], col = \"red\")\n\n\n\n\n\n\n\n\n\n\n\nZoom in mz values 521.1 and 522.5 to reveal the isotopic envelope of that peak.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nplotSpectra(sp[2807], xlim = c(521.2, 522.5), type = \"l\")\nabline(v = precursorMz(ms_2)[2], col = \"red\")\n\n\n\n\n\n\n\n\n\n\n\nThe plotSpectra() function is used to plot all 10 MS2 spectra in one call.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nplotSpectra(ms_2[-1])\n\n\n\n\n\n\n\n\n\n\nIt is possible to label the peaks with the plotSpectra() function. The labels argument is either a character of appropriate length (i.e.¬†with a label for each peak) or, as illustrated below, a function that computes the labels.\n\nmzLabel &lt;- function(z) {\n    z &lt;- peaksData(z)[[1L]]\n    lbls &lt;- format(z[, \"mz\"], digits = 4)\n    lbls[z[, \"intensity\"] &lt; 1e5] &lt;- \"\"\n    lbls\n}\n\nplotSpectra(ms_2[7],\n            xlim = c(126, 132),\n            labels = mzLabel,\n            labelSrt = -30, labelPos = 2,\n            labelOffset = 0.1)\n\n\n\n\n\n\n\nSpectra can also be compared either by overlay or mirror plotting using the plotSpectraOverlay() and plotSpectraMirror() functions.\n\nFilter MS2 level spectra and find any 2 MS2 spectra that have matching precursor peaks based on the precursor m/z values.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nsp2 &lt;- filterMsLevel(sp, 2L)\nanyDuplicated(precursorMz(filterMsLevel(sp, 2)))\n##  [1] 37\ni &lt;- which(precursorMz(sp2) == precursorMz(sp2)[37])\nsp2i &lt;- sp2[i]\n\n\n\n\n\nVisualise the matching pair using the plotSpectraOverlay() and plotSpectraMirror() functions.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nplotSpectraOverlay(sp2i, col = c(\"red\", \"steelblue\"))\n\n\n\n\n\n\n\n\nplotSpectraMirror(sp2i[1], sp2i[2])\n\n\n\n\n\n\n\n\n\n\nIt is also possible to explore raw data interactively with the SpectraVis package:\n\nThe browseSpectra() function opens a simple shiny application that allows to browse through the individual scans of a Spectra object.\nThe plotlySpectra() function displays a single spectrum using plotly allowing to explore (zooming, panning) the spectrum interactively.\nTest the SpectraVis function on some the Spectra objects produce above."
  },
  {
    "objectID": "pages/raw-ms-data.html#raw-data-processing-and-manipulation",
    "href": "pages/raw-ms-data.html#raw-data-processing-and-manipulation",
    "title": "2¬† Raw MS data",
    "section": "\n2.3 Raw data processing and manipulation",
    "text": "2.3 Raw data processing and manipulation\nApart from classical subsetting operations such as [ and split, a set of filter functions are defined for Spectra objects that filter/reduce the number of spectra within the object (for detailed help please see the ?Spectra help):\n\n\nfilterAcquisitionNum: retains spectra with certain acquisition numbers.\n\nfilterDataOrigin: subsets to spectra from specific origins.\n\nfilterDataStorage: subsets to spectra from certain data storage files.\n\nfilterEmptySpectra: removes spectra without mass peaks.\n\nfilterMzRange: subsets spectra keeping only peaks with an m/z within the provided m/z range.\n\nfilterIsolationWindow: keeps spectra with the provided mz in their isolation window (m/z range).\n\nfilterMsLevel: filters by MS level.\n\nfilterPolarity: filters by polarity.\n\nfilterPrecursorIsotopes: identifies precursor ions (from fragment spectra) that could represent isotopes of the same molecule. For each of these spectra groups only the spectrum of the monoisotopic precursor ion is returned. MS1 spectra are returned without filtering.\n\nfilterPrecursorMaxIntensity: filters spectra keeping, for groups of spectra with similar precursor m/z, the one spectrum with the highest precursor intensity. All MS1 spectra are returned without filtering.\n\nfilterPrecursorMzRange: retains (MSn) spectra with a precursor m/z within the provided m/z range.\n\nfilterPrecursorMzValues: retains (MSn) spectra with precursor m/z value matching the provided value(s) considering also a tolerance and ppm.\n\nfilterPrecursorCharge: retains (MSn) spectra with speified precursor charge(s).\n\nfilterPrecursorScan: retains (parent and children) scans of an acquisition number.\n\nfilterRt: filters based on retention time range.\n\nIn addition to these, there is also a set of filter functions that operate on the peak data, filtering and modifying the number of peaks of each spectrum within a Spectra:\n\ncombinePeaks: groups peaks within each spectrum based on similarity of their m/z values and combines these into a single peak per peak group.\ndeisotopeSpectra: deisotopes each individual spectrum keeping only the monoisotopic peak for peaks groups of potential isotopologues.\nfilterIntensity: filter each spectrum keeping only peaks with intensities meeting certain criteria.\nfilterMzRange: subsets peaks data within each spectrum keeping only peaks with their m/z values within the specified m/z range.\nfilterPrecursorPeaks: removes peaks with either an m/z value matching the precursor m/z of the respective spectrum (with parameter mz = \"==\") or peaks with an m/z value larger or equal to the precursor m/z (with parameter mz = \"&gt;=\").\nfilterMzValues: subsets peaks within each spectrum keeping or removing (all) peaks matching provided m/z value(s) (given parameters ppm and tolerance).\nreduceSpectra: filters individual spectra keeping only the largest peak for groups of peaks with similar m/z values.\nUsing the sp_sciex data, select all spectra measured in the second mzML file and subsequently filter them to retain spectra measured between 175 and 189 seconds in the measurement run.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nfls &lt;- unique(dataOrigin(sp_sciex))\nfls\n##  [1] \"/usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_1_105-134.mzML\"\n##  [2] \"/usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_3_105-134.mzML\"\nfile_2 &lt;- filterDataOrigin(sp_sciex, dataOrigin = fls[2])\nlength(file_2)\n##  [1] 931\nsps_sub &lt;- filterRt(file_2, rt = c(175, 189))\nlength(sps_sub)\n##  [1] 50\n\n\nsp_sciex |&gt;\n    filterDataOrigin(fls[2]) |&gt;\n    filterRt(c(175, 189))\n##  MSn data (Spectra) with 50 spectra in a MsBackendMzR backend:\n##        msLevel     rtime scanIndex\n##      &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1           1   175.212       628\n##  2           1   175.491       629\n##  3           1   175.770       630\n##  4           1   176.049       631\n##  5           1   176.328       632\n##  ...       ...       ...       ...\n##  46          1   187.768       673\n##  47          1   188.047       674\n##  48          1   188.326       675\n##  49          1   188.605       676\n##  50          1   188.884       677\n##   ... 33 more variables/columns.\n##  \n##  file(s):\n##  20171016_POOL_POS_3_105-134.mzML\n##  Processing:\n##   Filter: select data origin(s) /usr/local/lib/R/site-library/msdata/sciex/20171016_POOL_POS_3_105-134.mzML [Tue Dec  5 16:30:13 2023]\n##   Filter: select retention time [175..189] on MS level(s) 1 [Tue Dec  5 16:30:13 2023]\n\n\n\n\nAs an example of data processing, we use below the pickPeaks() function. This function allows to convert profile mode MS data to centroid mode data (a process also referred to as centroiding).\n\nplotSpectra(sp[2807], xlim = c(521.2, 522.5))\n\n\n\n\n\n\n\nCentroiding reduces the profile mode MS data to a representative single mass peak per ion.\n\npickPeaks(sp[2807]) |&gt;\n    filterIntensity(1e7) |&gt;\n    plotSpectra(xlim = c(521.2, 522.5))"
  },
  {
    "objectID": "pages/raw-ms-data.html#a-note-on-efficiency",
    "href": "pages/raw-ms-data.html#a-note-on-efficiency",
    "title": "2¬† Raw MS data",
    "section": "\n2.4 A note on efficiency",
    "text": "2.4 A note on efficiency\n\n2.4.1 Backends\nThe figure below (taken from (Gatto, Gibb, and Rainer 2020)) illustrates the respective advantages of storing data in memory or on disk. The benchmarking was done for the MSnbase package but also applies to the Spectra backends.\n\n\n\n\n(a) Reading time (triplicates, in seconds) and (b) data size in memory (in MB) to read/store 1, 5, and 10 files containing 1431 MS1 (on-disk only) and 6103 MS2 (on-disk and in-memory) spectra. (c) Filtering benchmark assessed over 10 interactions on in-memory and on-disk data containing 6103 MS2 spectra. (d) Access time to spectra for the in-memory (left) and on-disk (right) backends for 1, 10, 100 1000, 5000, and all 6103 spectra. Benchmarks were performed on a Dell XPS laptop with an Intel i5-8250U processor 1.60 GHz (4 cores, 8 threads), 7.5 GB RAM running Ubuntu 18.04.4 LTS 64-bit, and an SSD drive. The data used for the benchmarking are a TMT 4-plex experiment acquired on a LTQ Orbitrap Velos (Thermo Fisher Scientific) available in the msdata package.\n\n\n\n\n2.4.2 Parallel processing\nMost functions on Spectra support (and use) parallel processing out of the box. Peak data access and manipulation methods perform by default parallel processing on a per-file basis (i.e.¬†using the dataStorage variable as splitting factor). Spectra uses BiocParallel for parallel processing and all functions use the default registered parallel processing setup of that package.\n\n2.4.3 Lazy evaluation\nData manipulations on Spectra objects are not immediately applied to the peak data. They are added to a so called processing queue which is applied each time peak data is accessed (with the peaksData, mz or intensity functions). Thanks to this processing queue data manipulation operations are also possible for read-only backends (e.g.¬†mzML-file based backends or database-based backends). The information about the number of such processing steps can be seen below (next to Lazy evaluation queue).\n\nmin(intensity(sp_sciex[1]))\n##  [1] 0\nsp_sciex &lt;- filterIntensity(sp_sciex, intensity = c(10, Inf))\nsp_sciex ## Note the lazy evaluation queue\n##  MSn data (Spectra) with 1862 spectra in a MsBackendMzR backend:\n##         msLevel     rtime scanIndex\n##       &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1            1     0.280         1\n##  2            1     0.559         2\n##  3            1     0.838         3\n##  4            1     1.117         4\n##  5            1     1.396         5\n##  ...        ...       ...       ...\n##  1858         1   258.636       927\n##  1859         1   258.915       928\n##  1860         1   259.194       929\n##  1861         1   259.473       930\n##  1862         1   259.752       931\n##   ... 33 more variables/columns.\n##  \n##  file(s):\n##  20171016_POOL_POS_1_105-134.mzML\n##  20171016_POOL_POS_3_105-134.mzML\n##  Lazy evaluation queue: 1 processing step(s)\n##  Processing:\n##   Remove peaks with intensities outside [10, Inf] in spectra of MS level(s) 1. [Tue Dec  5 16:30:13 2023]\nmin(intensity(sp_sciex[1]))\n##  [1] 412\nsp_sciex@processingQueue\n##  [[1]]\n##  Object of class \"ProcessingStep\"\n##   Function: user-provided function\n##   Arguments:\n##    o intensity = 10Inf\n##    o msLevel = 1\n\nThrough this lazy evaluation system it is also possible to undo data manipulations:\n\nsp_sciex &lt;- reset(sp_sciex)\nsp_sciex@processingQueue\n##  list()\nmin(intensity(sp_sciex[1]))\n##  [1] 0\n\nMore information on this lazy evaluation concept implemented in Spectra is provided in the Spectra backends vignette."
  },
  {
    "objectID": "pages/raw-ms-data.html#footnotes",
    "href": "pages/raw-ms-data.html#footnotes",
    "title": "2¬† Raw MS data",
    "section": "",
    "text": "As defined in the Bioconductor S4Vectors package.‚Ü©Ô∏é"
  },
  {
    "objectID": "pages/20-id.html",
    "href": "pages/20-id.html",
    "title": "3¬† Identification data",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "pages/20-id.html#identification-data.frame",
    "href": "pages/20-id.html#identification-data.frame",
    "title": "3¬† Identification data",
    "section": "\n3.1 Identification data.frame",
    "text": "3.1 Identification data.frame\nLet‚Äôs use the identification from msdata:\n\nidf &lt;- msdata::ident(full.names = TRUE)\nbasename(idf)\n##  [1] \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\"\n\nThe easiest way to read identification data in mzIdentML (often abbreviated with mzid) into R is to read it with the readPSMs() function from the PSMatch package1. The function will parse the file and return a DataFrame.\n\nlibrary(PSMatch)\nid &lt;- PSM(idf)\ndim(id)\n##  [1] 5802   35\nnames(id)\n##   [1] \"sequence\"                 \"spectrumID\"              \n##   [3] \"chargeState\"              \"rank\"                    \n##   [5] \"passThreshold\"            \"experimentalMassToCharge\"\n##   [7] \"calculatedMassToCharge\"   \"peptideRef\"              \n##   [9] \"modNum\"                   \"isDecoy\"                 \n##  [11] \"post\"                     \"pre\"                     \n##  [13] \"start\"                    \"end\"                     \n##  [15] \"DatabaseAccess\"           \"DBseqLength\"             \n##  [17] \"DatabaseSeq\"              \"DatabaseDescription\"     \n##  [19] \"scan.number.s.\"           \"acquisitionNum\"          \n##  [21] \"spectrumFile\"             \"idFile\"                  \n##  [23] \"MS.GF.RawScore\"           \"MS.GF.DeNovoScore\"       \n##  [25] \"MS.GF.SpecEValue\"         \"MS.GF.EValue\"            \n##  [27] \"MS.GF.QValue\"             \"MS.GF.PepQValue\"         \n##  [29] \"modPeptideRef\"            \"modName\"                 \n##  [31] \"modMass\"                  \"modLocation\"             \n##  [33] \"subOriginalResidue\"       \"subReplacementResidue\"   \n##  [35] \"subLocation\"\n\n\n\n\n\n\n\nQuestion\n\n\n\nVerify that this table contains 5802 matches for 5343 scans and 4938 peptides sequences.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nnrow(id) ## number of matches\n##  [1] 5802\nlength(unique(id$spectrumID)) ## number of scans\n##  [1] 5343\nlength(unique(id$sequence))   ## number of peptide sequences\n##  [1] 4938\n\n\n\n\n\n\nThe PSM data are read as is, without any filtering. As we can see below, we still have all the hits from the forward and reverse (decoy) databases.\n\ntable(id$isDecoy)\n##  \n##  FALSE  TRUE \n##   2906  2896"
  },
  {
    "objectID": "pages/20-id.html#keeping-all-matches",
    "href": "pages/20-id.html#keeping-all-matches",
    "title": "3¬† Identification data",
    "section": "\n3.2 Keeping all matches",
    "text": "3.2 Keeping all matches\nThe data contains also contains multiple matches for several spectra. The table below shows the number of number of spectra that have 1, 2, ‚Ä¶ up to 5 matches.\n\ntable(table(id$spectrumID))\n##  \n##     1    2    3    4    5 \n##  4936  369   26   10    2\n\nBelow, we can see how scan 1774 has 4 matches, all to sequence RTRYQAEVR, which itself matches to 4 different proteins:\n\ni &lt;- which(id$spectrumID == \"controllerType=0 controllerNumber=1 scan=1774\")\ndata.frame(id[i, ])[1:5]\n##     sequence                                    spectrumID chargeState rank\n##  1 RTRYQAEVR controllerType=0 controllerNumber=1 scan=1774           2    1\n##  2 RTRYQAEVR controllerType=0 controllerNumber=1 scan=1774           2    1\n##  3 RTRYQAEVR controllerType=0 controllerNumber=1 scan=1774           2    1\n##  4 RTRYQAEVR controllerType=0 controllerNumber=1 scan=1774           2    1\n##    passThreshold\n##  1          TRUE\n##  2          TRUE\n##  3          TRUE\n##  4          TRUE\n\nIf the goal is to keep all the matches, but arranged by scan/spectrum, one can reduce the PSM object by the spectrumID variable, so that each scan correponds to a single row that still stores all values2:\n\nid2 &lt;- reducePSMs(id, id$spectrumID)\nid2\n##  Reduced PSM with 5343 rows and 35 columns.\n##  names(35): sequence spectrumID ... subReplacementResidue subLocation\n\nThe resulting object contains a single entry for scan 1774 with information for the multiple matches stored as lists within the cells.\n\nj &lt;- which(id2$spectrumID == \"controllerType=0 controllerNumber=1 scan=1774\")\nid2[j, ]\n##  Reduced PSM with 1 rows and 35 columns.\n##  names(35): sequence spectrumID ... subReplacementResidue subLocation\n\n\nid2[j, \"DatabaseAccess\"]\n##  CharacterList of length 1\n##  [[\"controllerType=0 controllerNumber=1 scan=1774\"]] ECA2104 ... ECA4142\n\nThe is the type of complete identification table that could be used to annotate an raw mass spectrometry Spectra object, as shown below."
  },
  {
    "objectID": "pages/20-id.html#filtering-data",
    "href": "pages/20-id.html#filtering-data",
    "title": "3¬† Identification data",
    "section": "\n3.3 Filtering data",
    "text": "3.3 Filtering data\nOften, the PSM data is filtered to only retain reliable matches. The MSnID package can be used to set thresholds to attain user-defined PSM, peptide or protein-level FDRs. Here, we will simply filter out wrong identification manually.\nHere, the filter() from the dplyr package comes very handy. We will thus start by converting the DataFrame to a tibble.\n\nlibrary(dplyr)\nid_tbl &lt;- tidyr::as_tibble(id)\nid_tbl\n##  # A tibble: 5,802 √ó 35\n##    sequence                  spectrumID        chargeState  rank passThreshold\n##    &lt;chr&gt;                     &lt;chr&gt;                   &lt;int&gt; &lt;int&gt; &lt;lgl&gt;        \n##  1 RQCRTDFLNYLR              controllerType=0‚Ä¶           3     1 TRUE         \n##  2 ESVALADQVTCVDWRNRKATKK    controllerType=0‚Ä¶           2     1 TRUE         \n##  3 KELLCLAMQIIR              controllerType=0‚Ä¶           2     1 TRUE         \n##  4 QRMARTSDKQQSIRFLERLCGR    controllerType=0‚Ä¶           3     1 TRUE         \n##  5 KDEGSTEPLKVVRDMTDAICMLLR  controllerType=0‚Ä¶           3     1 TRUE         \n##  6 DGGPAIYGHERVGRNAKKFKCLKFR controllerType=0‚Ä¶           3     1 TRUE         \n##  # ‚Ñπ 5,796 more rows\n##  # ‚Ñπ 30 more variables: experimentalMassToCharge &lt;dbl&gt;, ‚Ä¶\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nRemove decoy hits\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nid_tbl &lt;- id_tbl |&gt; \n    filter(!isDecoy)\nid_tbl\n##  # A tibble: 2,906 √ó 35\n##    sequence                    spectrumID      chargeState  rank passThreshold\n##    &lt;chr&gt;                       &lt;chr&gt;                 &lt;int&gt; &lt;int&gt; &lt;lgl&gt;        \n##  1 RQCRTDFLNYLR                controllerType‚Ä¶           3     1 TRUE         \n##  2 ESVALADQVTCVDWRNRKATKK      controllerType‚Ä¶           2     1 TRUE         \n##  3 QRMARTSDKQQSIRFLERLCGR      controllerType‚Ä¶           3     1 TRUE         \n##  4 DGGPAIYGHERVGRNAKKFKCLKFR   controllerType‚Ä¶           3     1 TRUE         \n##  5 QRMARTSDKQQSIRFLERLCGR      controllerType‚Ä¶           2     1 TRUE         \n##  6 CIDRARHVEVQIFGDGKGRVVALGER‚Ä¶ controllerType‚Ä¶           3     1 TRUE         \n##  # ‚Ñπ 2,900 more rows\n##  # ‚Ñπ 30 more variables: experimentalMassToCharge &lt;dbl&gt;, ‚Ä¶\n\n\n\n\n\nKeep first rank matches\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nid_tbl &lt;- id_tbl |&gt; \n    filter(rank == 1)\nid_tbl\n##  # A tibble: 2,751 √ó 35\n##    sequence                    spectrumID      chargeState  rank passThreshold\n##    &lt;chr&gt;                       &lt;chr&gt;                 &lt;int&gt; &lt;int&gt; &lt;lgl&gt;        \n##  1 RQCRTDFLNYLR                controllerType‚Ä¶           3     1 TRUE         \n##  2 ESVALADQVTCVDWRNRKATKK      controllerType‚Ä¶           2     1 TRUE         \n##  3 QRMARTSDKQQSIRFLERLCGR      controllerType‚Ä¶           3     1 TRUE         \n##  4 DGGPAIYGHERVGRNAKKFKCLKFR   controllerType‚Ä¶           3     1 TRUE         \n##  5 QRMARTSDKQQSIRFLERLCGR      controllerType‚Ä¶           2     1 TRUE         \n##  6 CIDRARHVEVQIFGDGKGRVVALGER‚Ä¶ controllerType‚Ä¶           3     1 TRUE         \n##  # ‚Ñπ 2,745 more rows\n##  # ‚Ñπ 30 more variables: experimentalMassToCharge &lt;dbl&gt;, ‚Ä¶\n\n\n\n\n\nRemove shared peptides. Start by identifying scans that match different proteins. For example scan 4884 matches proteins XXX_ECA3406 and ECA3415. Scan 4099 match XXX_ECA4416_1, XXX_ECA4416_2 and XXX_ECA4416_3. Then remove the scans that match any of these proteins.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmltm &lt;-\n    id_tbl |&gt; \n    group_by(spectrumID) |&gt; \n    mutate(nProts = length(unique(DatabaseAccess))) |&gt; \n    filter(nProts &gt; 1) |&gt; \n    select(spectrumID, nProts)\nmltm\n##  # A tibble: 85 √ó 2\n##  # Groups:   spectrumID [39]\n##    spectrumID                                    nProts\n##    &lt;chr&gt;                                          &lt;int&gt;\n##  1 controllerType=0 controllerNumber=1 scan=1073      2\n##  2 controllerType=0 controllerNumber=1 scan=1073      2\n##  3 controllerType=0 controllerNumber=1 scan=6578      2\n##  4 controllerType=0 controllerNumber=1 scan=6578      2\n##  5 controllerType=0 controllerNumber=1 scan=5617      2\n##  6 controllerType=0 controllerNumber=1 scan=5617      2\n##  # ‚Ñπ 79 more rows\n\n\nid_tbl &lt;-\n    id_tbl |&gt; \n    filter(!spectrumID %in% mltm$spectrumID)\nid_tbl\n##  # A tibble: 2,666 √ó 35\n##    sequence                    spectrumID      chargeState  rank passThreshold\n##    &lt;chr&gt;                       &lt;chr&gt;                 &lt;int&gt; &lt;int&gt; &lt;lgl&gt;        \n##  1 RQCRTDFLNYLR                controllerType‚Ä¶           3     1 TRUE         \n##  2 ESVALADQVTCVDWRNRKATKK      controllerType‚Ä¶           2     1 TRUE         \n##  3 QRMARTSDKQQSIRFLERLCGR      controllerType‚Ä¶           3     1 TRUE         \n##  4 DGGPAIYGHERVGRNAKKFKCLKFR   controllerType‚Ä¶           3     1 TRUE         \n##  5 QRMARTSDKQQSIRFLERLCGR      controllerType‚Ä¶           2     1 TRUE         \n##  6 CIDRARHVEVQIFGDGKGRVVALGER‚Ä¶ controllerType‚Ä¶           3     1 TRUE         \n##  # ‚Ñπ 2,660 more rows\n##  # ‚Ñπ 30 more variables: experimentalMassToCharge &lt;dbl&gt;, ‚Ä¶\n\n\n\n\n\n\nWhich leaves us with 2666 PSMs.\nThis can also be achieved with the filterPSMs() function, or the individual filterPsmRank(), filterPsmDecoy and filterPsmShared() functions:\n\nid_filtered &lt;- filterPSMs(id)\n##  Starting with 5802 PSMs:\n##  Removed 2896 decoy hits.\n##  Removed 155 PSMs with rank &gt; 1.\n##  Removed 85 shared peptides.\n##  2666 PSMs left.\n\nThe describePeptides() and describeProteins() functions from the PSMatch package provide useful summaries of preptides and proteins in a PSM search result.\n\n\ndescribePeptides() gives the number of unique and shared peptides and for the latter, the size of their protein groups:\n\n\ndescribePeptides(id_filtered)\n##  2324 peptides composed of\n##   unique peptides: 2324\n##   shared peptides (among protein):\n##    ()\n\n\n\ndescribeProteins() gives the number of proteins defined by only unique, only shared, or a mixture of unique/shared peptides:\n\n\ndescribeProteins(id_filtered)\n##  1466 proteins composed of\n##   only unique peptides: 1466\n##   only shared peptides: 0\n##   unique and shared peptides: 0\n\nThe Understanding protein groups with adjacency matrices PSMatch vignette provides additional tools to explore how proteins were inferred from peptides.\n\n\n\n\n\n\nQuestion\n\n\n\nCompare the distribution of raw identification scores of the decoy and non-decoy hits. Interpret the figure.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlibrary(ggplot2)\nas_tibble(id) |&gt; \n    ggplot(aes(x = MS.GF.RawScore,\n               colour = isDecoy)) +\n    geom_density()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nThe tidyverse tools are fit for data wrangling with identification data. Using the above identification dataframe, calculate the length of each peptide (you can use nchar with the peptide sequence sequence) and the number of peptides for each protein (defined as DatabaseDescription). Plot the length of the proteins against their respective number of peptides.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\niddf &lt;- as_tibble(id_filtered) |&gt; \n    mutate(peplen = nchar(sequence))\nnpeps &lt;- iddf |&gt; \n    group_by(DatabaseAccess) |&gt; \n    tally()\niddf &lt;- full_join(iddf, npeps)\n##  Joining with `by = join_by(DatabaseAccess)`\n\nggplot(iddf, aes(x = n, y = DBseqLength)) + geom_point()\n\n\n\nIdentifcation data wrangling.\n\n\n\n\n\n\n\n\nIf you would like to learn more about how the mzid data are handled by PSMatch via the mzR and mzID packages, check out the @ref(sec-id2) section in the annex."
  },
  {
    "objectID": "pages/20-id.html#adding-identification-data-to-raw-data",
    "href": "pages/20-id.html#adding-identification-data-to-raw-data",
    "title": "3¬† Identification data",
    "section": "\n3.4 Adding identification data to raw data",
    "text": "3.4 Adding identification data to raw data\nWe are goind to use the sp object created in the previous chapter and the id_filtered variable generated above.\n\n\n\n\n\n\nGenerating the sp object from scratch üëá\n\n\n\n\n\n\nlibrary(rpx)\nlibrary(Spectra)\n##  Loading required package: BiocParallel\n##  Loading required package: ProtGenerics\n##  \n##  Attaching package: 'ProtGenerics'\n##  The following object is masked from 'package:stats':\n##  \n##      smooth\nfn &lt;- \"TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\"\npx &lt;- PXDataset(\"PXD000001\")\n##  Loading PXD000001 from cache.\nmzf &lt;- pxget(px, fn)\n##  Loading TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML from cache.\nsp &lt;- Spectra(mzf)\nsp\n##  MSn data (Spectra) with 7534 spectra in a MsBackendMzR backend:\n##         msLevel     rtime scanIndex\n##       &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1            1    0.4584         1\n##  2            1    0.9725         2\n##  3            1    1.8524         3\n##  4            1    2.7424         4\n##  5            1    3.6124         5\n##  ...        ...       ...       ...\n##  7530         2   3600.47      7530\n##  7531         2   3600.83      7531\n##  7532         2   3601.18      7532\n##  7533         2   3601.57      7533\n##  7534         2   3601.98      7534\n##   ... 33 more variables/columns.\n##  \n##  file(s):\n##  d177d1ab84_TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n\n\n\n\nIdentification data (as a DataFrame) can be merged into raw data (as a Spectra object) by adding new spectra variables to the appropriate MS2 spectra. Scans and peptide-spectrum matches can be matched by their spectrum identifers.\n\n\n\n\n\n\nQuestion\n\n\n\nIdentify the spectum identifier columns in the sp the id_filtered variables.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nIn the raw data, it is encoded as spectrumId, while in the identification data, we have spectrumID.\n\nspectraVariables(sp)\n##   [1] \"msLevel\"                  \"rtime\"                   \n##   [3] \"acquisitionNum\"           \"scanIndex\"               \n##   [5] \"dataStorage\"              \"dataOrigin\"              \n##   [7] \"centroided\"               \"smoothed\"                \n##   [9] \"polarity\"                 \"precScanNum\"             \n##  [11] \"precursorMz\"              \"precursorIntensity\"      \n##  [13] \"precursorCharge\"          \"collisionEnergy\"         \n##  [15] \"isolationWindowLowerMz\"   \"isolationWindowTargetMz\" \n##  [17] \"isolationWindowUpperMz\"   \"peaksCount\"              \n##  [19] \"totIonCurrent\"            \"basePeakMZ\"              \n##  [21] \"basePeakIntensity\"        \"ionisationEnergy\"        \n##  [23] \"lowMZ\"                    \"highMZ\"                  \n##  [25] \"mergedScan\"               \"mergedResultScanNum\"     \n##  [27] \"mergedResultStartScanNum\" \"mergedResultEndScanNum\"  \n##  [29] \"injectionTime\"            \"filterString\"            \n##  [31] \"spectrumId\"               \"ionMobilityDriftTime\"    \n##  [33] \"scanWindowLowerLimit\"     \"scanWindowUpperLimit\"\nnames(id_filtered)\n##   [1] \"sequence\"                 \"spectrumID\"              \n##   [3] \"chargeState\"              \"rank\"                    \n##   [5] \"passThreshold\"            \"experimentalMassToCharge\"\n##   [7] \"calculatedMassToCharge\"   \"peptideRef\"              \n##   [9] \"modNum\"                   \"isDecoy\"                 \n##  [11] \"post\"                     \"pre\"                     \n##  [13] \"start\"                    \"end\"                     \n##  [15] \"DatabaseAccess\"           \"DBseqLength\"             \n##  [17] \"DatabaseSeq\"              \"DatabaseDescription\"     \n##  [19] \"scan.number.s.\"           \"acquisitionNum\"          \n##  [21] \"spectrumFile\"             \"idFile\"                  \n##  [23] \"MS.GF.RawScore\"           \"MS.GF.DeNovoScore\"       \n##  [25] \"MS.GF.SpecEValue\"         \"MS.GF.EValue\"            \n##  [27] \"MS.GF.QValue\"             \"MS.GF.PepQValue\"         \n##  [29] \"modPeptideRef\"            \"modName\"                 \n##  [31] \"modMass\"                  \"modLocation\"             \n##  [33] \"subOriginalResidue\"       \"subReplacementResidue\"   \n##  [35] \"subLocation\"\n\n\n\n\n\n\nWe still have several PTMs that are matched to a single spectrum identifier:\n\ntable(table(id_filtered$spectrumID))\n##  \n##     1    2    3    4 \n##  2630   13    2    1\n\nLet‚Äôs look at \"controllerType=0 controllerNumber=1 scan=5490\", the has 4 matching PSMs in detail.\n\nwhich(table(id_filtered$spectrumID) == 4)\n##  controllerType=0 controllerNumber=1 scan=5490 \n##                                           1903\nid_4 &lt;- id_filtered[id_filtered$spectrumID == \"controllerType=0 controllerNumber=1 scan=5490\", ] |&gt; \n    as.data.frame()\nid_4\n##            sequence                                    spectrumID chargeState\n##  1 KCNQCLKVACTLFYCK controllerType=0 controllerNumber=1 scan=5490           3\n##  2 KCNQCLKVACTLFYCK controllerType=0 controllerNumber=1 scan=5490           3\n##  3 KCNQCLKVACTLFYCK controllerType=0 controllerNumber=1 scan=5490           3\n##  4 KCNQCLKVACTLFYCK controllerType=0 controllerNumber=1 scan=5490           3\n##    rank passThreshold experimentalMassToCharge calculatedMassToCharge\n##  1    1          TRUE                 698.6633               698.3315\n##  2    1          TRUE                 698.6633               698.3315\n##  3    1          TRUE                 698.6633               698.3315\n##  4    1          TRUE                 698.6633               698.3315\n##    peptideRef modNum isDecoy post pre start end DatabaseAccess DBseqLength\n##  1     Pep453      4   FALSE    C   K   127 142        ECA0668         302\n##  2     Pep453      4   FALSE    C   K   127 142        ECA0668         302\n##  3     Pep453      4   FALSE    C   K   127 142        ECA0668         302\n##  4     Pep453      4   FALSE    C   K   127 142        ECA0668         302\n##    DatabaseSeq          DatabaseDescription scan.number.s. acquisitionNum\n##  1             ECA0668 hypothetical protein           5490           5490\n##  2             ECA0668 hypothetical protein           5490           5490\n##  3             ECA0668 hypothetical protein           5490           5490\n##  4             ECA0668 hypothetical protein           5490           5490\n##                                                           spectrumFile\n##  1 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##  2 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##  3 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##  4 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##                                                                 idFile\n##  1 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\n##  2 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\n##  3 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\n##  4 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\n##    MS.GF.RawScore MS.GF.DeNovoScore MS.GF.SpecEValue MS.GF.EValue\n##  1            -22                79     4.555588e-07     1.307689\n##  2            -22                79     4.555588e-07     1.307689\n##  3            -22                79     4.555588e-07     1.307689\n##  4            -22                79     4.555588e-07     1.307689\n##    MS.GF.QValue MS.GF.PepQValue modPeptideRef         modName  modMass\n##  1    0.9006211       0.8901099        Pep453 Carbamidomethyl 57.02146\n##  2    0.9006211       0.8901099        Pep453 Carbamidomethyl 57.02146\n##  3    0.9006211       0.8901099        Pep453 Carbamidomethyl 57.02146\n##  4    0.9006211       0.8901099        Pep453 Carbamidomethyl 57.02146\n##    modLocation subOriginalResidue subReplacementResidue subLocation\n##  1           2               &lt;NA&gt;                  &lt;NA&gt;          NA\n##  2           5               &lt;NA&gt;                  &lt;NA&gt;          NA\n##  3          10               &lt;NA&gt;                  &lt;NA&gt;          NA\n##  4          15               &lt;NA&gt;                  &lt;NA&gt;          NA\n\nWe can see that these 4 PSMs differ by the location of the Carbamidomethyl modification.\n\nid_4[, c(\"modName\", \"modLocation\")]\n##            modName modLocation\n##  1 Carbamidomethyl           2\n##  2 Carbamidomethyl           5\n##  3 Carbamidomethyl          10\n##  4 Carbamidomethyl          15\n\nLet‚Äôs reduce that PSM table before joining it to the Spectra object, to make sure we have unique one-to-one matches between the raw spectra and the PSMs.\n\nid_filtered &lt;- reducePSMs(id_filtered, id_filtered$spectrumID)\nid_filtered\n##  Reduced PSM with 2646 rows and 35 columns.\n##  names(35): sequence spectrumID ... subReplacementResidue subLocation\n\nThese two data can thus simply be joined using:\n\nsp &lt;- joinSpectraData(sp, id_filtered,\n                      by.x = \"spectrumId\",\n                      by.y = \"spectrumID\")\nspectraVariables(sp)\n##   [1] \"msLevel\"                  \"rtime\"                   \n##   [3] \"acquisitionNum\"           \"scanIndex\"               \n##   [5] \"dataStorage\"              \"dataOrigin\"              \n##   [7] \"centroided\"               \"smoothed\"                \n##   [9] \"polarity\"                 \"precScanNum\"             \n##  [11] \"precursorMz\"              \"precursorIntensity\"      \n##  [13] \"precursorCharge\"          \"collisionEnergy\"         \n##  [15] \"isolationWindowLowerMz\"   \"isolationWindowTargetMz\" \n##  [17] \"isolationWindowUpperMz\"   \"peaksCount\"              \n##  [19] \"totIonCurrent\"            \"basePeakMZ\"              \n##  [21] \"basePeakIntensity\"        \"ionisationEnergy\"        \n##  [23] \"lowMZ\"                    \"highMZ\"                  \n##  [25] \"mergedScan\"               \"mergedResultScanNum\"     \n##  [27] \"mergedResultStartScanNum\" \"mergedResultEndScanNum\"  \n##  [29] \"injectionTime\"            \"filterString\"            \n##  [31] \"spectrumId\"               \"ionMobilityDriftTime\"    \n##  [33] \"scanWindowLowerLimit\"     \"scanWindowUpperLimit\"    \n##  [35] \"sequence\"                 \"chargeState\"             \n##  [37] \"rank\"                     \"passThreshold\"           \n##  [39] \"experimentalMassToCharge\" \"calculatedMassToCharge\"  \n##  [41] \"peptideRef\"               \"modNum\"                  \n##  [43] \"isDecoy\"                  \"post\"                    \n##  [45] \"pre\"                      \"start\"                   \n##  [47] \"end\"                      \"DatabaseAccess\"          \n##  [49] \"DBseqLength\"              \"DatabaseSeq\"             \n##  [51] \"DatabaseDescription\"      \"scan.number.s.\"          \n##  [53] \"acquisitionNum.y\"         \"spectrumFile\"            \n##  [55] \"idFile\"                   \"MS.GF.RawScore\"          \n##  [57] \"MS.GF.DeNovoScore\"        \"MS.GF.SpecEValue\"        \n##  [59] \"MS.GF.EValue\"             \"MS.GF.QValue\"            \n##  [61] \"MS.GF.PepQValue\"          \"modPeptideRef\"           \n##  [63] \"modName\"                  \"modMass\"                 \n##  [65] \"modLocation\"              \"subOriginalResidue\"      \n##  [67] \"subReplacementResidue\"    \"subLocation\"\n\n\n\n\n\n\n\nQuestion\n\n\n\nVerify that the identification data has been added to the correct spectra.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nLet‚Äôs first verify that no identification data has been added to the MS1 scans.\n\nall(is.na(filterMsLevel(sp, 1)$sequence))\n##  [1] TRUE\n\nThey have indeed been added to 56% of the MS2 spectra.\n\nsp_2 &lt;- filterMsLevel(sp, 2)\ntable(is.na(sp_2$sequence))\n##  \n##  FALSE  TRUE \n##   2646  3457\n\nLet‚Äôs compare the precursor/peptide mass to charges\n\nsp_2 &lt;- sp_2[!is.na(sp_2$sequence)]\nsummary(sp_2$precursorMz - sp_2$experimentalMassToCharge)\n##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   0.0000  0.0000  0.0000  0.0053  0.0000  2.0297"
  },
  {
    "objectID": "pages/20-id.html#an-identification-annotated-chromatogram",
    "href": "pages/20-id.html#an-identification-annotated-chromatogram",
    "title": "3¬† Identification data",
    "section": "\n3.5 An identification-annotated chromatogram",
    "text": "3.5 An identification-annotated chromatogram\nNow that we have combined raw data and their associated peptide-spectrum matches, we can produce an improved total ion chromatogram, identifying MS1 scans that lead to successful identifications.\nThe countIdentifications() function is going to tally the number of identifications (i.e non-missing characters in the sequence spectra variable) for each scan. In the case of MS2 scans, these will be either 1 or 0, depending on the presence of a sequence. For MS1 scans, the function will count the number of sequences for the descendant MS2 scans, i.e.¬†those produced from precursor ions from each MS1 scan.\n\nsp &lt;- countIdentifications(sp)\n\nBelow, we see on the second line that 3457 MS2 scans lead to no PSM, while 2546 lead to an identification. Among all MS1 scans, 833 lead to no MS2 scans with PSMs. 30 MS1 scans generated one MS2 scan that lead to a PSM, 45 lead to two PSMs, ‚Ä¶\n\ntable(msLevel(sp), sp$countIdentifications)\n##     \n##         0    1    2    3    4    5    6    7    8    9   10\n##    1  833   30   45   97  139  132   92   42   17    3    1\n##    2 3457 2646    0    0    0    0    0    0    0    0    0\n\nThese data can also be visualised on the total ion chromatogram:\n\nsp |&gt;\n    filterMsLevel(1) |&gt;\n    spectraData() |&gt;\n    as_tibble() |&gt;\n    ggplot(aes(x = rtime,\n            y = totIonCurrent)) +\n    geom_line(alpha = 0.25) +\n    geom_point(aes(colour = ifelse(countIdentifications == 0,\n                                   NA, countIdentifications)),\n               size = 0.75,\n               alpha = 0.5) +\n    labs(colour = \"Number of ids\")"
  },
  {
    "objectID": "pages/20-id.html#visualising-peptide-spectrum-matches",
    "href": "pages/20-id.html#visualising-peptide-spectrum-matches",
    "title": "3¬† Identification data",
    "section": "\n3.6 Visualising peptide-spectrum matches",
    "text": "3.6 Visualising peptide-spectrum matches\nLet‚Äôs choose a MS2 spectrum with a high identification score and plot it.\n\ni &lt;- which(sp$MS.GF.RawScore &gt; 100)[1]\nplotSpectra(sp[i])\n\n\n\n\n\n\n\nWe have seen above that we can add labels to each peak using the labels argument in plotSpectra(). The addFragments() function takes a spectrum as input (that is a Spectra object of length 1) and annotates its peaks.\n\naddFragments(sp[i])\n##    [1] NA     NA     NA     \"b1\"   NA     NA     NA     NA     NA     NA    \n##   [11] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##   [21] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##   [31] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##   [41] NA     NA     NA     \"y1_\"  NA     NA     NA     NA     NA     \"y1\"  \n##   [51] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##   [61] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##   [71] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##   [81] NA     NA     NA     NA     NA     NA     \"b2\"   NA     NA     NA    \n##   [91] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##  [101] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##  [111] NA     NA     NA     NA     NA     NA     NA     \"y2_\"  \"y2*\"  NA    \n##  [121] NA     \"y2\"   NA     NA     NA     NA     NA     NA     NA     NA    \n##  [131] NA     NA     \"b3\"   NA     NA     NA     NA     NA     NA     NA    \n##  [141] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##  [151] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##  [161] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##  [171] \"y3*\"  NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##  [181] \"y3\"   NA     \"b4_\"  NA     NA     NA     NA     NA     NA     NA    \n##  [191] NA     NA     \"b4\"   NA     NA     NA     NA     NA     NA     NA    \n##  [201] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##  [211] NA     NA     NA     NA     NA     NA     NA     \"y4*\"  NA     \"b5_\" \n##  [221] \"b5*\"  NA     \"y4\"   NA     \"b5\"   NA     NA     NA     NA     NA    \n##  [231] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##  [241] NA     NA     NA     NA     NA     NA     \"y5_\"  \"y5*\"  NA     \"b6_\" \n##  [251] \"y5\"   NA     NA     \"b6\"   NA     NA     NA     NA     NA     NA    \n##  [261] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##  [271] NA     \"y6*\"  \"b7_\"  NA     \"y6\"   NA     NA     \"b7\"   NA     NA    \n##  [281] NA     NA     NA     NA     NA     NA     \"y7_\"  \"y7*\"  NA     \"y7\"  \n##  [291] NA     \"b8\"   NA     NA     NA     NA     \"y8_\"  \"y8*\"  \"y8\"   NA    \n##  [301] NA     NA     NA     NA     NA     NA     NA     NA     NA     NA    \n##  [311] \"y9_\"  \"y9*\"  NA     \"y9\"   NA     NA     NA     NA     NA     NA    \n##  [321] \"y10_\" \"y10*\" NA     \"y10\"  NA     NA     NA\n\nIt can be directly used with plotSpectra():\n\nplotSpectra(sp[i], labels = addFragments,\n            labelPos = 3, labelCol = \"steelblue\")\n\n\n\n\n\n\n\nWhen a precursor peptide ion is fragmented in a CID cell, it breaks at specific bonds, producing sets of peaks (a, b, c and x, y, z) that can be predicted.\n\n\n\n\nPeptide fragmentation.\n\n\n\nThe annotation of spectra is obtained by simulating fragmentation of a peptide and matching observed peaks to fragments:\n\nsp[i]$sequence\n##  [1] \"THSQEEMQHMQR\"\ncalculateFragments(sp[i]$sequence)\n##  Modifications used: C=57.02146\n##            mz  ion type pos z         seq\n##  1   102.0550   b1    b   1 1           T\n##  2   239.1139   b2    b   2 1          TH\n##  3   326.1459   b3    b   3 1         THS\n##  4   454.2045   b4    b   4 1        THSQ\n##  5   583.2471   b5    b   5 1       THSQE\n##  6   712.2897   b6    b   6 1      THSQEE\n##  7   843.3301   b7    b   7 1     THSQEEM\n##  8   971.3887   b8    b   8 1    THSQEEMQ\n##  9  1108.4476   b9    b   9 1   THSQEEMQH\n##  10 1239.4881  b10    b  10 1  THSQEEMQHM\n##  11 1367.5467  b11    b  11 1 THSQEEMQHMQ\n##  12  175.1190   y1    y   1 1           R\n##  13  303.1775   y2    y   2 1          QR\n##  14  434.2180   y3    y   3 1         MQR\n##  15  571.2769   y4    y   4 1        HMQR\n##  16  699.3355   y5    y   5 1       QHMQR\n##  17  830.3760   y6    y   6 1      MQHMQR\n##  18  959.4186   y7    y   7 1     EMQHMQR\n##  19 1088.4612   y8    y   8 1    EEMQHMQR\n##  20 1216.5198   y9    y   9 1   QEEMQHMQR\n##  21 1303.5518  y10    y  10 1  SQEEMQHMQR\n##  22 1440.6107  y11    y  11 1 HSQEEMQHMQR\n##  23  436.1939  b4_   b_   4 1        THSQ\n##  24  565.2365  b5_   b_   5 1       THSQE\n##  25  694.2791  b6_   b_   6 1      THSQEE\n##  26  825.3196  b7_   b_   7 1     THSQEEM\n##  27  953.3782  b8_   b_   8 1    THSQEEMQ\n##  28 1090.4371  b9_   b_   9 1   THSQEEMQH\n##  29 1221.4776 b10_   b_  10 1  THSQEEMQHM\n##  30 1349.5361 b11_   b_  11 1 THSQEEMQHMQ\n##  31  941.4080  y7_   y_   7 1     EMQHMQR\n##  32 1070.4506  y8_   y_   8 1    EEMQHMQR\n##  33 1422.6001 y11_   y_  11 1 HSQEEMQHMQR\n##  34  157.1084  y1_   y_   1 1           R\n##  35  285.1670  y2_   y_   2 1          QR\n##  36  416.2075  y3_   y_   3 1         MQR\n##  37  553.2664  y4_   y_   4 1        HMQR\n##  38  681.3249  y5_   y_   5 1       QHMQR\n##  39  812.3654  y6_   y_   6 1      MQHMQR\n##  40 1198.5092  y9_   y_   9 1   QEEMQHMQR\n##  41 1285.5412 y10_   y_  10 1  SQEEMQHMQR\n##  42  566.2205  b5*   b*   5 1       THSQE\n##  43  695.2631  b6*   b*   6 1      THSQEE\n##  44  826.3036  b7*   b*   7 1     THSQEEM\n##  45  954.3622  b8*   b*   8 1    THSQEEMQ\n##  46 1091.4211  b9*   b*   9 1   THSQEEMQH\n##  47 1222.4616 b10*   b*  10 1  THSQEEMQHM\n##  48 1350.5202 b11*   b*  11 1 THSQEEMQHMQ\n##  49  286.1510  y2*   y*   2 1          QR\n##  50  417.1915  y3*   y*   3 1         MQR\n##  51  554.2504  y4*   y*   4 1        HMQR\n##  52  682.3090  y5*   y*   5 1       QHMQR\n##  53  813.3495  y6*   y*   6 1      MQHMQR\n##  54  942.3920  y7*   y*   7 1     EMQHMQR\n##  55 1071.4346  y8*   y*   8 1    EEMQHMQR\n##  56 1199.4932  y9*   y*   9 1   QEEMQHMQR\n##  57 1286.5252 y10*   y*  10 1  SQEEMQHMQR\n##  58 1423.5842 y11*   y*  11 1 HSQEEMQHMQR"
  },
  {
    "objectID": "pages/20-id.html#comparing-spectra",
    "href": "pages/20-id.html#comparing-spectra",
    "title": "3¬† Identification data",
    "section": "\n3.7 Comparing spectra",
    "text": "3.7 Comparing spectra\nThe compareSpectra() function can be used to compare spectra (by default, computing the normalised dot product).\n\n\n\n\n\n\nQuestion\n\n\n\nCreate a new Spectra object containing the MS2 spectra with sequences \"SQILQQAGTSVLSQANQVPQTVLSLLR\" and \"TKGLNVMQNLLTAHPDVQAVFAQNDEMALGALR\".\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nk &lt;- which(sp$sequence %in% c(\"SQILQQAGTSVLSQANQVPQTVLSLLR\", \"TKGLNVMQNLLTAHPDVQAVFAQNDEMALGALR\"))\nsp_k &lt;- sp[k]\nsp_k\n##  MSn data (Spectra) with 5 spectra in a MsBackendMzR backend:\n##      msLevel     rtime scanIndex\n##    &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1         2   2687.42      5230\n##  2         2   2688.88      5235\n##  3         2   2748.75      5397\n##  4         2   2765.26      5442\n##  5         2   2768.17      5449\n##   ... 68 more variables/columns.\n##  \n##  file(s):\n##  d177d1ab84_TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nCalculate the 5 by 5 similarity matrix between all spectra using compareSpectra. See the ?Spectra man page for details. Draw a heatmap of that matrix.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nmat &lt;- compareSpectra(sp_k)\nrownames(mat) &lt;- colnames(mat) &lt;- strtrim(sp_k$sequence, 2)\nmat\n##               TK          TK           SQ          SQ           SQ\n##  TK 1.0000000000 0.109126094 0.0009373465 0.001261338 0.0008256185\n##  TK 0.1091260942 1.000000000 0.0025314670 0.001459654 0.0017613212\n##  SQ 0.0009373465 0.002531467 1.0000000000 0.432133016 0.6879331218\n##  SQ 0.0012613380 0.001459654 0.4321330158 1.000000000 0.4467153012\n##  SQ 0.0008256185 0.001761321 0.6879331218 0.446715301 1.0000000000\npheatmap::pheatmap(mat)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nCompare the spectra with the plotting function seen previously.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nfilterIntensity(sp_k, 1e3) |&gt;  plotSpectra(main = sp_k$sequence)\npar(mfrow = c(3, 1))\n\n\n\n\n\n\nplotSpectraMirror(sp_k[1], sp_k[2], main = \"TK...\")\nplotSpectraMirror(sp_k[3], sp_k[4], main = \"SQ...\")\nplotSpectraMirror(sp_k[3], sp_k[4], main = \"SQ...\")"
  },
  {
    "objectID": "pages/20-id.html#summary-exercise",
    "href": "pages/20-id.html#summary-exercise",
    "title": "3¬† Identification data",
    "section": "\n3.8 Summary exercise",
    "text": "3.8 Summary exercise\n\n\n\n\n\n\nQuestion\n\n\n\nDownload the 3 first mzML and mzID files from the PXD022816 project (Morgenstern, Barzilay, and Levin 2021).\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n## Getting data from PX/PRIDE\nlibrary(rpx)\n\n## https://www.ebi.ac.uk/pride/archive/projects/PXD022816\n## RawBeans: A Simple, Vendor-Independent, Raw-Data Quality-Control\n## Tool ()\n\nPXD022816 &lt;- PXDataset(\"PXD022816\")\n##  Querying ProteomeXchange for PXD022816.\nPXD022816\n##  Project PXD022816 with 32 files\n##  \n##  Resource ID BFC3 in cache in /root/.cache/R/rpx.\n##   [1] 'QEP2LC6_HeLa_50ng_251120_01-calib.mzID.gz' ... [32] 'checksum.txt'\n##   Use 'pxfiles(.)' to see all files.\n\npxfiles(PXD022816)\n##  Project PXD022816 files (32):\n##   [remote] QEP2LC6_HeLa_50ng_251120_01-calib.mzID.gz\n##   [remote] QEP2LC6_HeLa_50ng_251120_01-calib.mzML\n##   [remote] QEP2LC6_HeLa_50ng_251120_01.raw\n##   [remote] QEP2LC6_HeLa_50ng_251120_02-calib.mzID.gz\n##   [remote] QEP2LC6_HeLa_50ng_251120_02-calib.mzML\n##   [remote] QEP2LC6_HeLa_50ng_251120_02.raw\n##   [remote] QEP2LC6_HeLa_50ng_251120_03-calib.mzID.gz\n##   [remote] QEP2LC6_HeLa_50ng_251120_03-calib.mzML\n##   [remote] QEP2LC6_HeLa_50ng_251120_03.raw\n##   [remote] QEP2LC6_HeLa_50ng_251120_04-calib.mzID.gz\n##   ...\n\n(mzids &lt;- pxget(PXD022816, grep(\"mzID\", pxfiles(PXD022816))[1:3]))\n##  Project PXD022816 files (32):\n##   [remote] QEP2LC6_HeLa_50ng_251120_01-calib.mzID.gz\n##   [remote] QEP2LC6_HeLa_50ng_251120_01-calib.mzML\n##   [remote] QEP2LC6_HeLa_50ng_251120_01.raw\n##   [remote] QEP2LC6_HeLa_50ng_251120_02-calib.mzID.gz\n##   [remote] QEP2LC6_HeLa_50ng_251120_02-calib.mzML\n##   [remote] QEP2LC6_HeLa_50ng_251120_02.raw\n##   [remote] QEP2LC6_HeLa_50ng_251120_03-calib.mzID.gz\n##   [remote] QEP2LC6_HeLa_50ng_251120_03-calib.mzML\n##   [remote] QEP2LC6_HeLa_50ng_251120_03.raw\n##   [remote] QEP2LC6_HeLa_50ng_251120_04-calib.mzID.gz\n##   ...\n##  Downloading QEP2LC6_HeLa_50ng_251120_01-calib.mzID.gz file.\n##  Downloading QEP2LC6_HeLa_50ng_251120_02-calib.mzID.gz file.\n##  Downloading QEP2LC6_HeLa_50ng_251120_03-calib.mzID.gz file.\n##  [1] \"/root/.cache/R/rpx/15c31fe8b54_QEP2LC6_HeLa_50ng_251120_01-calib.mzID.gz\"\n##  [2] \"/root/.cache/R/rpx/15c41f88c10_QEP2LC6_HeLa_50ng_251120_02-calib.mzID.gz\"\n##  [3] \"/root/.cache/R/rpx/15c6ad49c14_QEP2LC6_HeLa_50ng_251120_03-calib.mzID.gz\"\n(mzmls &lt;- pxget(PXD022816, grep(\"mzML\", pxfiles(PXD022816))[1:3]))\n##  Project PXD022816 files (32):\n##   [local]  QEP2LC6_HeLa_50ng_251120_01-calib.mzID.gz\n##   [remote] QEP2LC6_HeLa_50ng_251120_01-calib.mzML\n##   [remote] QEP2LC6_HeLa_50ng_251120_01.raw\n##   [local]  QEP2LC6_HeLa_50ng_251120_02-calib.mzID.gz\n##   [remote] QEP2LC6_HeLa_50ng_251120_02-calib.mzML\n##   [remote] QEP2LC6_HeLa_50ng_251120_02.raw\n##   [local]  QEP2LC6_HeLa_50ng_251120_03-calib.mzID.gz\n##   [remote] QEP2LC6_HeLa_50ng_251120_03-calib.mzML\n##   [remote] QEP2LC6_HeLa_50ng_251120_03.raw\n##   [remote] QEP2LC6_HeLa_50ng_251120_04-calib.mzID.gz\n##   ...\n##  Downloading QEP2LC6_HeLa_50ng_251120_01-calib.mzML file.\n##  Downloading QEP2LC6_HeLa_50ng_251120_02-calib.mzML file.\n##  Downloading QEP2LC6_HeLa_50ng_251120_03-calib.mzML file.\n##  [1] \"/root/.cache/R/rpx/15c1af8434c_QEP2LC6_HeLa_50ng_251120_01-calib.mzML\"\n##  [2] \"/root/.cache/R/rpx/15c2c4818d9_QEP2LC6_HeLa_50ng_251120_02-calib.mzML\"\n##  [3] \"/root/.cache/R/rpx/15c584379d5_QEP2LC6_HeLa_50ng_251120_03-calib.mzML\"\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nGenerate a Spectra object and a table of filtered PSMs. Visualise the total ion chromatograms and check the quality of the identification data by comparing the density of the decoy and target PSMs id scores for each file.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n## Loading raw data\nlibrary(Spectra)\nsp &lt;- Spectra(mzmls)\nsp\n##  MSn data (Spectra) with 87647 spectra in a MsBackendMzR backend:\n##          msLevel     rtime scanIndex\n##        &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1             1  0.177987         1\n##  2             1  0.599870         2\n##  3             1  0.978849         3\n##  4             1  1.363217         4\n##  5             1  1.742965         5\n##  ...         ...       ...       ...\n##  87643         1   4198.64     28736\n##  87644         1   4199.02     28737\n##  87645         2   4199.28     28738\n##  87646         1   4199.44     28739\n##  87647         1   4199.82     28740\n##   ... 33 more variables/columns.\n##  \n##  file(s):\n##  15c1af8434c_QEP2LC6_HeLa_50ng_251120_01-calib.mzML\n##  15c2c4818d9_QEP2LC6_HeLa_50ng_251120_02-calib.mzML\n##  15c584379d5_QEP2LC6_HeLa_50ng_251120_03-calib.mzML\n\n## number of spectra per file\ntable(basename(sp$dataOrigin))\n##  \n##  15c1af8434c_QEP2LC6_HeLa_50ng_251120_01-calib.mzML \n##                                               29575 \n##  15c2c4818d9_QEP2LC6_HeLa_50ng_251120_02-calib.mzML \n##                                               29332 \n##  15c584379d5_QEP2LC6_HeLa_50ng_251120_03-calib.mzML \n##                                               28740\n\n## all levels are centroided\ntable(sp$centroided, sp$msLevel)\n##        \n##             1     2\n##    TRUE 19607 68040\n\n\nlibrary(ggplot2)\nlibrary(tidyr)\nlibrary(magrittr)\n\n## Chromatograms\nfilterMsLevel(sp, 1) |&gt; \n    spectraData() |&gt; \n    as_tibble() |&gt; \n    ggplot(aes(x = rtime,\n               y = totIonCurrent,\n               colour = basename(dataOrigin))) +\n    geom_line()\n\n\n\n\n\n\n\n\n## Identification data\nlibrary(PSMatch)\nid &lt;- PSM(mzids)\n\n## Number of PSMs per acquisition\ntable(id$idFile)\n##  \n##  15c31fe8b54_QEP2LC6_HeLa_50ng_251120_01-calib.mzID.gz \n##                                                  25231 \n##  15c41f88c10_QEP2LC6_HeLa_50ng_251120_02-calib.mzID.gz \n##                                                  25083 \n##  15c6ad49c14_QEP2LC6_HeLa_50ng_251120_03-calib.mzID.gz \n##                                                  24436\n\ntidyr::as_tibble(id) |&gt; \n    ggplot(aes(x = MetaMorpheus.score,\n               colour = isDecoy)) +\n    geom_density() +\n    facet_wrap(~ spectrumFile)\n\n\n\n\n\n\n\n\nid_filtered &lt;- filterPSMs(id)\n##  Starting with 74750 PSMs:\n##  Removed 543 decoy hits.\n##  Removed 0 PSMs with rank &gt; 1.\n##  Removed 11310 shared peptides.\n##  62897 PSMs left.\nmax(id_filtered$PSM.level.q.value)\n##  [1] 0.009994817\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nJoin the raw and identification data. Beware though that the joining must now be performed by spectrum ids and by files.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n## primary key for spectra\nsp$pkey &lt;-\n    paste0(sub(\"^.+_QEP\", \"QEP\", basename(dataOrigin(sp))),\n           gsub(\"^.+=\", \"::\", sp$spectrumId))\nhead(sp$pkey)\n##  [1] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::1\"\n##  [2] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::2\"\n##  [3] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::3\"\n##  [4] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::4\"\n##  [5] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::5\"\n##  [6] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::6\"\n\n## primary key for PSMs\nid_filtered$pkey &lt;-\n    paste0(gsub(\"^.+\\\\QEP\", \"QEP\", id_filtered$spectrumFile),\n           sub(\"^.+=\", \"::\", id_filtered$spectrumID))\nhead(id_filtered$pkey)\n##  [1] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::3426\" \n##  [2] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::20165\"\n##  [3] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::20180\"\n##  [4] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::15180\"\n##  [5] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::10327\"\n##  [6] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::12894\"\n\n## For simplicity, let keep single hits per spectrum id.\n## Alternatively, explore duplicates and use QFeatures::reduceDataFrame\nid_filtered &lt;- id_filtered[!duplicated(id_filtered$pkey), ]\n\nhead(id_filtered$pkey)\n##  [1] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::3426\" \n##  [2] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::20165\"\n##  [3] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::20180\"\n##  [4] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::15180\"\n##  [5] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::10327\"\n##  [6] \"QEP2LC6_HeLa_50ng_251120_01-calib.mzML::12894\"\n\nsp &lt;- joinSpectraData(sp, id_filtered, by.x = \"pkey\")\n\n## Number of MS2 scans with a PSM\ntable(!is.na(filterMsLevel(sp, 2)$sequence))\n##  \n##  FALSE  TRUE \n##  22006 46034\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nExtract the PSMs that have been matched to peptides from protein O43175 and compare and cluster the scans. Hint: once you have created the smaller Spectra object with the scans of interest, switch to an in-memory backend to seed up the calculations.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nsp_O43175 &lt;- sp[which(sp$DatabaseAccess == \"O43175\")]\nsp_O43175 &lt;- setBackend(sp_O43175, MsBackendDataFrame())\nsp_O43175\n##  MSn data (Spectra) with 77 spectra in a MsBackendDataFrame backend:\n##        msLevel     rtime scanIndex\n##      &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt;\n##  1           2   1496.36      8143\n##  2           2   1518.19      8362\n##  3           2   1582.59      9009\n##  4           2   1587.08      9056\n##  5           2   1708.69     10288\n##  ...       ...       ...       ...\n##  73          2   3148.28     23503\n##  74          2   3242.61     24333\n##  75          2   3436.78     25513\n##  76          2   3547.90     26170\n##  77          2   3563.78     26314\n##   ... 65 more variables/columns.\n##  Processing:\n##   Switch backend from MsBackendMzR to MsBackendDataFrame [Tue Dec  5 16:31:49 2023]\n\ncmat &lt;- compareSpectra(sp_O43175)\nrownames(cmat) &lt;-\n    colnames(cmat) &lt;- strtrim(sp_O43175$sequence, 3)\n\npheatmap::pheatmap(cmat)\n\n\n\n\n\n\n\n(i &lt;- which(rownames(cmat) == \"DLP\"))\n##  [1] 21 23 45 46 49 73 74 77\n\nplotSpectra(sp_O43175[i], labels = addFragments,\n            labelPos = 3, labelCol = \"steelblue\",\n            main = sp_O43175$sequence[i])\n\nspectraData(sp_O43175[i])$precursorCharge\n##  [1] 2 2 2 2 2 2 2 2\nspectraData(sp_O43175[i])$precursorMz\n##  [1] 493.8055 515.3086 493.8383 493.8380 515.3084 493.8057 493.8390 515.3087\nspectraData(sp_O43175[i])$modName\n##  [1] NA         \"Carbamyl\" NA         NA         \"Carbamyl\" NA        \n##  [7] NA         \"Carbamyl\"\n\n\n\n\n\n\n\n\n## Directly compare spectra with/without Carbamyl\nplotSpectraMirror(sp_O43175[4], sp_O43175[9])\n\n\n\n\n\n\nplotSpectraMirror(sp_O43175[2], sp_O43175[10])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nGenerate total ion chromatograms for each acquisition and annotate the MS1 scans with the number of PSMs using the countIdentifications() function, as shown above. The function will automatically perform the counts in parallel for each acquisition.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nsp &lt;- countIdentifications(sp)\ntable(msLevel(sp), sp$countIdentifications)\n##     \n##          0     1     2     3     4     5     6     7     8     9    10\n##    1 12937   488   254   213   237   345   588   991  1439  1401   714\n##    2 22006 46034     0     0     0     0     0     0     0     0     0\n\n\nsp |&gt;\n    filterMsLevel(1) |&gt;\n    spectraData() |&gt;\n    as_tibble() |&gt;\n    ggplot(aes(x = rtime, y = totIonCurrent)) +\n    geom_line(alpha = 0.25) +\n    geom_point(aes(colour = ifelse(countIdentifications == 0,\n                                NA, countIdentifications)),\n            size = 0.75,\n            alpha = 0.5) +\n    scale_colour_gradient(low = \"orange\", high = \"red\") +\n    facet_grid(sub(\"^.+_\", \"\", basename(dataOrigin)) ~ .) +\n    labs(colour = \"Number of ids\")"
  },
  {
    "objectID": "pages/20-id.html#exploration-and-assessment-of-identifications-using-msnid",
    "href": "pages/20-id.html#exploration-and-assessment-of-identifications-using-msnid",
    "title": "3¬† Identification data",
    "section": "\n3.9 Exploration and Assessment of Identifications using MSnID\n",
    "text": "3.9 Exploration and Assessment of Identifications using MSnID\n\nThe MSnID package extracts MS/MS ID data from mzIdentML (leveraging the mzID package) or text files. After collating the search results from multiple datasets it assesses their identification quality and optimises filtering criteria to achieve the maximum number of identifications while not exceeding a specified false discovery rate. It also contains a number of utilities to explore the MS/MS results and assess missed and irregular enzymatic cleavages, mass measurement accuracy, etc.\n\n3.9.1 Step-by-step work-flow\nLet‚Äôs reproduce parts of the analysis described the MSnID vignette. You can explore more with\n\nvignette(\"msnid_vignette\", package = \"MSnID\")\n\nThe MSnID package can be used for post-search filtering of MS/MS identifications. One starts with the construction of an MSnID object that is populated with identification results that can be imported from a data.frame or from mzIdenML files. Here, we will use the example identification data provided with the package.\n\nmzids &lt;- system.file(\"extdata\", \"c_elegans.mzid.gz\", package=\"MSnID\")\nbasename(mzids)\n##  [1] \"c_elegans.mzid.gz\"\n\nWe start by loading the package, initialising the MSnID object, and add the identification result from our mzid file (there could of course be more than one).\n\nlibrary(MSnID)\n##  Loading required package: Rcpp\n##  \n##  Attaching package: 'MSnID'\n##  The following object is masked from 'package:ProtGenerics':\n##  \n##      peptides\nmsnid &lt;- MSnID(\".\")\n##  Note, the anticipated/suggested columns in the\n##  peptide-to-spectrum matching results are:\n##  -----------------------------------------------\n##  accession\n##  calculatedMassToCharge\n##  chargeState\n##  experimentalMassToCharge\n##  isDecoy\n##  peptide\n##  spectrumFile\n##  spectrumID\nmsnid &lt;- read_mzIDs(msnid, mzids)\n##  Reading from mzIdentMLs ...\n##  reading c_elegans.mzid.gz... DONE!\nshow(msnid)\n##  MSnID object\n##  Working directory: \".\"\n##  #Spectrum Files:  1 \n##  #PSMs: 12263 at 36 % FDR\n##  #peptides: 9489 at 44 % FDR\n##  #accessions: 7414 at 76 % FDR\n\nPrinting the MSnID object returns some basic information such as\n\nWorking directory.\nNumber of spectrum files used to generate data.\nNumber of peptide-to-spectrum matches and corresponding FDR.\nNumber of unique peptide sequences and corresponding FDR.\nNumber of unique proteins or amino acid sequence accessions and corresponding FDR.\n\nThe package then enables to define, optimise and apply filtering based for example on missed cleavages, identification scores, precursor mass errors, etc. and assess PSM, peptide and protein FDR levels. To properly function, it expects to have access to the following data\n\n##  [1] \"accession\"                \"calculatedMassToCharge\"  \n##  [3] \"chargeState\"              \"experimentalMassToCharge\"\n##  [5] \"isDecoy\"                  \"peptide\"                 \n##  [7] \"spectrumFile\"             \"spectrumID\"\n\nwhich are indeed present in our data:\n\nnames(msnid)\n##   [1] \"spectrumID\"                \"scan number(s)\"           \n##   [3] \"acquisitionNum\"            \"passThreshold\"            \n##   [5] \"rank\"                      \"calculatedMassToCharge\"   \n##   [7] \"experimentalMassToCharge\"  \"chargeState\"              \n##   [9] \"MS-GF:DeNovoScore\"         \"MS-GF:EValue\"             \n##  [11] \"MS-GF:PepQValue\"           \"MS-GF:QValue\"             \n##  [13] \"MS-GF:RawScore\"            \"MS-GF:SpecEValue\"         \n##  [15] \"AssumedDissociationMethod\" \"IsotopeError\"             \n##  [17] \"isDecoy\"                   \"post\"                     \n##  [19] \"pre\"                       \"end\"                      \n##  [21] \"start\"                     \"accession\"                \n##  [23] \"length\"                    \"description\"              \n##  [25] \"pepSeq\"                    \"modified\"                 \n##  [27] \"modification\"              \"idFile\"                   \n##  [29] \"spectrumFile\"              \"databaseFile\"             \n##  [31] \"peptide\"\n\nHere, we summarise a few steps and redirect the reader to the package‚Äôs vignette for more details:\n\n3.9.2 Analysis of peptide sequences\nCleaning irregular cleavages at the termini of the peptides and missing cleavage site within the peptide sequences. The following two function calls create the new numMisCleavages and numIrregCleavages columns in the MSnID object\n\nmsnid &lt;- assess_termini(msnid, validCleavagePattern=\"[KR]\\\\.[^P]\")\nmsnid &lt;- assess_missed_cleavages(msnid, missedCleavagePattern=\"[KR](?=[^P$])\")\n\n\n3.9.3 Trimming the data\nNow, we can use the apply_filter function to effectively apply filters. The strings passed to the function represent expressions that will be evaluated, thus keeping only PSMs that have 0 irregular cleavages and 2 or less missed cleavages.\n\nmsnid &lt;- apply_filter(msnid, \"numIrregCleavages == 0\")\nmsnid &lt;- apply_filter(msnid, \"numMissCleavages &lt;= 2\")\nshow(msnid)\n##  MSnID object\n##  Working directory: \".\"\n##  #Spectrum Files:  1 \n##  #PSMs: 7838 at 17 % FDR\n##  #peptides: 5598 at 23 % FDR\n##  #accessions: 3759 at 53 % FDR\n\n\n3.9.4 Parent ion mass errors\nUsing \"calculatedMassToCharge\" and \"experimentalMassToCharge\", the mass_measurement_error function calculates the parent ion mass measurement error in parts per million.\n\nsummary(mass_measurement_error(msnid))\n##        Min.    1st Qu.     Median       Mean    3rd Qu.       Max. \n##  -2184.0640    -0.6992     0.0000    17.6146     0.7512  2012.5178\n\nWe then filter any matches that do not fit the +/- 20 ppm tolerance\n\nmsnid &lt;- apply_filter(msnid, \"abs(mass_measurement_error(msnid)) &lt; 20\")\nsummary(mass_measurement_error(msnid))\n##      Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \n##  -19.7797  -0.5866   0.0000  -0.2970   0.5713  19.6758\n\n\n3.9.5 Filtering criteria\nFiltering of the identification data will rely on\n\n-log10 transformed MS-GF+ Spectrum E-value, reflecting the goodness of match between experimental and theoretical fragmentation patterns\n\n\nmsnid$msmsScore &lt;- -log10(msnid$`MS-GF:SpecEValue`)\n\n\nthe absolute mass measurement error (in ppm units) of the parent ion\n\n\nmsnid$absParentMassErrorPPM &lt;- abs(mass_measurement_error(msnid))\n\n\n3.9.6 Setting filters\nMS2 filters are handled by a special MSnIDFilter class objects, where individual filters are set by name (that is present in names(msnid)) and comparison operator (&gt;, &lt;, = , ‚Ä¶) defining if we should retain hits with higher or lower given the threshold and finally the threshold value itself.\n\nfiltObj &lt;- MSnIDFilter(msnid)\nfiltObj$absParentMassErrorPPM &lt;- list(comparison=\"&lt;\", threshold=10.0)\nfiltObj$msmsScore &lt;- list(comparison=\"&gt;\", threshold=10.0)\nshow(filtObj)\n##  MSnIDFilter object\n##  (absParentMassErrorPPM &lt; 10) & (msmsScore &gt; 10)\n\nWe can then evaluate the filter on the identification data object, which returns the false discovery rate and number of retained identifications for the filtering criteria at hand.\n\nevaluate_filter(msnid, filtObj)\n##            fdr    n\n##  PSM         0 3807\n##  peptide     0 2455\n##  accession   0 1009\n\n\n3.9.7 Filter optimisation\nRather than setting filtering values by hand, as shown above, these can be set automatically to meet a specific false discovery rate.\n\nfiltObj.grid &lt;- optimize_filter(filtObj, msnid, fdr.max=0.01,\n                                method=\"Grid\", level=\"peptide\",\n                                n.iter=500)\nshow(filtObj.grid)\n##  MSnIDFilter object\n##  (absParentMassErrorPPM &lt; 3) & (msmsScore &gt; 7.4)\n\n\nevaluate_filter(msnid, filtObj.grid)\n##                    fdr    n\n##  PSM       0.004097561 5146\n##  peptide   0.006447651 3278\n##  accession 0.021996616 1208\n\nFilters can eventually be applied (rather than just evaluated) using the apply_filter function.\n\nmsnid &lt;- apply_filter(msnid, filtObj.grid)\nshow(msnid)\n##  MSnID object\n##  Working directory: \".\"\n##  #Spectrum Files:  1 \n##  #PSMs: 5146 at 0.41 % FDR\n##  #peptides: 3278 at 0.64 % FDR\n##  #accessions: 1208 at 2.2 % FDR\n\nAnd finally, identifications that matched decoy and contaminant protein sequences are removed\n\nmsnid &lt;- apply_filter(msnid, \"isDecoy == FALSE\")\nmsnid &lt;- apply_filter(msnid, \"!grepl('Contaminant',accession)\")\nshow(msnid)\n##  MSnID object\n##  Working directory: \".\"\n##  #Spectrum Files:  1 \n##  #PSMs: 5117 at 0 % FDR\n##  #peptides: 3251 at 0 % FDR\n##  #accessions: 1179 at 0 % FDR\n\n\n3.9.8 Export MSnID data\nThe resulting filtered identification data can be exported to a data.frame (or to a dedicated MSnSet data structure from the MSnbase package) for quantitative MS data, described below, and further processed and analysed using appropriate statistical tests.\n\nhead(psms(msnid))\n##    spectrumID scan number(s) acquisitionNum passThreshold rank\n##  1 index=7151           8819           7151          TRUE    1\n##  2 index=8520          10419           8520          TRUE    1\n##  3 index=6683           8279           6683          TRUE    1\n##  4 index=6683           8279           6683          TRUE    1\n##  5 index=6683           8279           6683          TRUE    1\n##  6 index=6683           8279           6683          TRUE    1\n##    calculatedMassToCharge experimentalMassToCharge chargeState\n##  1               1270.318                 1270.318           3\n##  2               1426.737                 1426.739           3\n##  3               1440.348                 1440.350           3\n##  4               1440.348                 1440.350           3\n##  5               1440.348                 1440.350           3\n##  6               1440.348                 1440.350           3\n##    MS-GF:DeNovoScore MS-GF:EValue MS-GF:PepQValue MS-GF:QValue MS-GF:RawScore\n##  1               287 1.709082e-24               0            0            239\n##  2               270 3.780745e-24               0            0            230\n##  3               294 1.106378e-23               0            0            224\n##  4               294 1.106378e-23               0            0            224\n##  5               294 1.106378e-23               0            0            224\n##  6               294 1.106378e-23               0            0            224\n##    MS-GF:SpecEValue AssumedDissociationMethod IsotopeError isDecoy post pre\n##  1     1.007452e-31                       CID            0   FALSE    A   K\n##  2     2.217275e-31                       CID            0   FALSE    A   K\n##  3     6.504763e-31                       CID            0   FALSE    W   K\n##  4     6.504763e-31                       CID            0   FALSE    W   K\n##  5     6.504763e-31                       CID            0   FALSE    W   K\n##  6     6.504763e-31                       CID            0   FALSE    W   K\n##    end start accession length\n##  1 283   249   CE02347    393\n##  2 182   142   CE07055    206\n##  3 422   385   CE12728    654\n##  4 422   385   CE36358    582\n##  5 355   318   CE36359    587\n##  6 386   349   CE36360    618\n##                                                                                                                            description\n##  1 WBGene00001993; locus:hpd-1; 4-hydroxyphenylpyruvate dioxygenase; status:Confirmed; UniProt:Q22633; protein_id:CAA90315.1; T21C12.2\n##  2           WBGene00001755; locus:gst-7; glutathione S-transferase; status:Confirmed; UniProt:P91253; protein_id:AAB37846.1; F11G11.2\n##  3                WBGene00011232; phosphoenolpyruvate carboxykinase; status:Confirmed; UniProt:O02286; protein_id:CAB05600.1; R11A5.4a\n##  4                                         WBGene00011232; status:Partially_confirmed; UniProt:Q7JKI1; protein_id:CAF31484.1; R11A5.4b\n##  5                                                   WBGene00011232; status:Confirmed; UniProt:Q7JKI3; protein_id:CAF31482.1; R11A5.4c\n##  6                                                   WBGene00011232; status:Confirmed; UniProt:Q7JKI2; protein_id:CAF31483.1; R11A5.4d\n##                                       pepSeq modified modification\n##  1       AISQIQEYVDYYGGSGVQHIALNTSDIITAIEALR    FALSE         &lt;NA&gt;\n##  2 SAGSGYLVGDSLTFVDLLVAQHTADLLAANAALLDEFPQFK    FALSE         &lt;NA&gt;\n##  3    NSIFTNVAETANGEYFWEGLEDEIADKNVDITTWLGEK    FALSE         &lt;NA&gt;\n##  4    NSIFTNVAETANGEYFWEGLEDEIADKNVDITTWLGEK    FALSE         &lt;NA&gt;\n##  5    NSIFTNVAETANGEYFWEGLEDEIADKNVDITTWLGEK    FALSE         &lt;NA&gt;\n##  6    NSIFTNVAETANGEYFWEGLEDEIADKNVDITTWLGEK    FALSE         &lt;NA&gt;\n##               idFile                                   spectrumFile\n##  1 c_elegans.mzid.gz c_elegans_A_3_1_21Apr10_Draco_10-03-04_dta.txt\n##  2 c_elegans.mzid.gz c_elegans_A_3_1_21Apr10_Draco_10-03-04_dta.txt\n##  3 c_elegans.mzid.gz c_elegans_A_3_1_21Apr10_Draco_10-03-04_dta.txt\n##  4 c_elegans.mzid.gz c_elegans_A_3_1_21Apr10_Draco_10-03-04_dta.txt\n##  5 c_elegans.mzid.gz c_elegans_A_3_1_21Apr10_Draco_10-03-04_dta.txt\n##  6 c_elegans.mzid.gz c_elegans_A_3_1_21Apr10_Draco_10-03-04_dta.txt\n##                databaseFile                                       peptide\n##  1 ID_004174_E48C5B52.fasta       K.AISQIQEYVDYYGGSGVQHIALNTSDIITAIEALR.A\n##  2 ID_004174_E48C5B52.fasta K.SAGSGYLVGDSLTFVDLLVAQHTADLLAANAALLDEFPQFK.A\n##  3 ID_004174_E48C5B52.fasta    K.NSIFTNVAETANGEYFWEGLEDEIADKNVDITTWLGEK.W\n##  4 ID_004174_E48C5B52.fasta    K.NSIFTNVAETANGEYFWEGLEDEIADKNVDITTWLGEK.W\n##  5 ID_004174_E48C5B52.fasta    K.NSIFTNVAETANGEYFWEGLEDEIADKNVDITTWLGEK.W\n##  6 ID_004174_E48C5B52.fasta    K.NSIFTNVAETANGEYFWEGLEDEIADKNVDITTWLGEK.W\n##    numIrregCleavages numMissCleavages msmsScore absParentMassErrorPPM\n##  1                 0                0  30.99678             0.3843772\n##  2                 0                0  30.65418             1.3689451\n##  3                 0                1  30.18677             0.9322561\n##  4                 0                1  30.18677             0.9322561\n##  5                 0                1  30.18677             0.9322561\n##  6                 0                1  30.18677             0.9322561"
  },
  {
    "objectID": "pages/20-id.html#footnotes",
    "href": "pages/20-id.html#footnotes",
    "title": "3¬† Identification data",
    "section": "",
    "text": "Previously named PSM.‚Ü©Ô∏é\nThe rownames aren‚Äôt needed here are are removed to reduce to output in the the next code chunk display parts of id2.‚Ü©Ô∏é"
  },
  {
    "objectID": "pages/30-quant.html",
    "href": "pages/30-quant.html",
    "title": "4¬† Quantitative data",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "pages/30-quant.html#quantitation-methodologies",
    "href": "pages/30-quant.html#quantitation-methodologies",
    "title": "4¬† Quantitative data",
    "section": "\n4.1 Quantitation methodologies",
    "text": "4.1 Quantitation methodologies\nThere are a wide range of proteomics quantitation techniques that can broadly be classified as labelled vs.¬†label-free, depending on whether the features are labelled prior the MS acquisition and the MS level at which quantitation is inferred, namely MS1 or MS2.\n\n\n\n\n\nLabel-free\nLabelled\n\n\n\nMS1\nXIC\nSILAC, 15N\n\n\nMS2\nCounting\niTRAQ, TMT\n\n\n\n\n\n\n4.1.1 Label-free MS2: Spectral counting\nIn spectral counting, one simply counts the number of quantified peptides that are assigned to a protein.\n\n\n\n\nSpectral counting. Figure from the Pbase package.\n\n\n\n\n4.1.2 Labelled MS2: Isobaric tagging\nIsobaric tagging refers to the labelling using isobaric tags, i.e.¬†chemical tags that have the same mass and hence can‚Äôt be distinguished by the spectrometer. The peptides of different samples (4, 6, 10, 11 or 16) are labelled with different tags and combined prior to mass spectrometry acquisition. Given that they are isobaric, all identical peptides, irrespective of the tag and this the sample of origin, are co-analysed, up to fragmentation prior to MS2 analysis. During fragmentation, the isobaric tags fall of, fragment themselves, and result in a set of sample specific peaks. These specific peaks can be used to infer sample-specific quantitation, while the rest of the MS2 spectrum is used for identification.\n\n\n\n\niTRAQ 4-plex isobaric tagging. Tandem Mass Tags (TMT) offer up to 16 tags.\n\n\n\n\n4.1.3 Label-free MS1: extracted ion chromatograms\nIn label-free quantitation, the precursor peaks that match an identified peptide are integrated over retention time and the area under that extracted ion chromatogram is used to quantify that peptide in that sample.\n\n\n\n\nLabel-free quantitation. Figure credit Johannes Rainer.\n\n\n\n\n4.1.4 Labelled MS1: SILAC\nIn SILAC quantitation, sample are grown in a medium that contains heavy amino acids (typically arginine and lysine). All proteins grown in this heavy growth medium contain the heavy form of these amino acids. Two samples, one grown in heavy medium, and one grown in normal (light) medium are then combined and analysed together. The heavy peptides precursor peaks are systematically shifted compared to the light ones, and the ratio between the height of a heavy and light peaks can be used to calculate peptide and protein fold-changes.\n\n\n\n\nSilac quantitation. Figure credit Wikimedia Commons.\n\n\n\nThese different quantitation techniques come with their respective benefits and distinct challenges, such as large quantities of raw data processing, data transformation and normalisation, missing values, and different underlying statistical models for the quantitative data (count data for spectral counting, continuous data for the others).\nIn terms of raw data quantitation in R/Bioconductor, most efforts have been devoted to MS2-level quantitation. Label-free XIC quantitation has been addressed in the frame of metabolomics data processing by the xcms infrastructure."
  },
  {
    "objectID": "pages/30-quant.html#sec-qf",
    "href": "pages/30-quant.html#sec-qf",
    "title": "4¬† Quantitative data",
    "section": "\n4.2 QFeatures",
    "text": "4.2 QFeatures\nMass spectrometry-based quantitative proteomics data can be represented as a matrix of quantitative values for features (PSMs, peptides, proteins) arranged along the rows, measured for a set of samples, arranged along the columns. There is a common representation for such quantitative data set, namely the SummarizedExperiment (Morgan et al. 2020) class:\n\n\n\n\nSchematic representation of the anatomy of a SummarizedExperiment object. (Figure taken from the SummarizedExperiment package vignette.)\n\n\n\n\nThe sample (columns) metadata can be accessed with the colData() function.\nThe features (rows) metadata can be accessed with the rowData() column.\nIf the features represent ranges along genomic coordinates, these can be accessed with rowRanges()\n\nAdditional metadata describing the overall experiment can be accessed with metadata().\nThe quantitative data can be accessed with assay().\n\nassays() returns a list of matrix-like assays.\n\n\n4.2.1 The QFeatures class\nWhile mass spectrometers acquire data for spectra/peptides, the biological entity of interest are the protein. As part of the data processing, we are thus required to aggregate low-level quantitative features into higher level data.\n\n\n\n\nConceptual representation of a QFeatures object and the aggregative relation between different assays.\n\n\n\nWe are going to start to familiarise ourselves with the QFeatures class implemented in the QFeatures package. The class is derived from the Bioconductor MultiAssayExperiment (Ramos et al. 2017) (MAE) class. Let‚Äôs start by loading the QFeatures package.\n\nlibrary(QFeatures)\n\nNext, we load the feat1 test data, which is composed of single assay of class SummarizedExperiment composed of 10 rows and 2 columns.\n\ndata(feat1)\nfeat1\n##  An instance of class QFeatures containing 1 assays:\n##   [1] psms: SummarizedExperiment with 10 rows and 2 columns\n\nLet‚Äôs perform some simple operations to familiarise ourselves with the QFeatures class:\n\n\n\n\n\n\nQuestion\n\n\n\n\nExtract the sample metadata using the colData() accessor (like you have previously done with SummarizedExperiment objects).\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncolData(feat1)\n##  DataFrame with 2 rows and 1 column\n##         Group\n##     &lt;integer&gt;\n##  S1         1\n##  S2         2\n\n\n\n\n\n\nWe can also further annotate the experiment by adding columns to the colData slot:\n\ncolData(feat1)$X &lt;- c(\"X1\", \"X2\")\nfeat1$Y &lt;- c(\"Y1\", \"Y2\")\ncolData(feat1)\n##  DataFrame with 2 rows and 3 columns\n##         Group           X           Y\n##     &lt;integer&gt; &lt;character&gt; &lt;character&gt;\n##  S1         1          X1          Y1\n##  S2         2          X2          Y2\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nExtract the first (and only) assay composing this QFeatures data using the [[ operator (as you have done to extract elements of a list) by using the assay‚Äôs index or name.\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nfeat1[[1]]\n##  class: SummarizedExperiment \n##  dim: 10 2 \n##  metadata(0):\n##  assays(1): ''\n##  rownames(10): PSM1 PSM2 ... PSM9 PSM10\n##  rowData names(5): Sequence Protein Var location pval\n##  colnames(2): S1 S2\n##  colData names(0):\nfeat1[[\"psms\"]]\n##  class: SummarizedExperiment \n##  dim: 10 2 \n##  metadata(0):\n##  assays(1): ''\n##  rownames(10): PSM1 PSM2 ... PSM9 PSM10\n##  rowData names(5): Sequence Protein Var location pval\n##  colnames(2): S1 S2\n##  colData names(0):\n\n\n\n\n\n\n\n4.2.2 Feature aggregation\nThe central functionality of the QFeatures infrastructure is the aggregation of features into higher-level features while retaining the link between the different levels. This can be done with the aggregateFeatures() function.\nThe call below will\n\noperate on the psms assay of the feat1 objects;\naggregate the rows of the assay following the grouping defined in the peptides row data variables;\nperform aggregation using the colMeans() function;\ncreate a new assay named peptides and add it to the feat1 object.\n\n\nfeat1 &lt;- aggregateFeatures(feat1, i = \"psms\",\n                           fcol = \"Sequence\",\n                           name = \"peptides\",\n                           fun = colMeans)\nfeat1\n##  An instance of class QFeatures containing 2 assays:\n##   [1] psms: SummarizedExperiment with 10 rows and 2 columns \n##   [2] peptides: SummarizedExperiment with 3 rows and 2 columns\n\n\nLet‚Äôs convince ourselves that we understand the effect of feature aggregation and repeat the calculations manually and check the content of the new assay‚Äôs row data.\n\n\n## SYGFNAAR\ncolMeans(assay(feat1[[1]])[1:3, ])\n##  S1 S2 \n##   2 12\nassay(feat1[[2]])[\"SYGFNAAR\", ]\n##  S1 S2 \n##   2 12\n\n## ELGNDAYK\ncolMeans(assay(feat1[[1]])[4:6, ])\n##  S1 S2 \n##   5 15\nassay(feat1[[2]])[\"ELGNDAYK\", ]\n##  S1 S2 \n##   5 15\n\n## IAEESNFPFIK\ncolMeans(assay(feat1[[1]])[7:10, ])\n##    S1   S2 \n##   8.5 18.5\nassay(feat1[[2]])[\"IAEESNFPFIK\", ]\n##    S1   S2 \n##   8.5 18.5\n\n\nrowData(feat1[[2]])\n##  DataFrame with 3 rows and 4 columns\n##                   Sequence     Protein      location        .n\n##                &lt;character&gt; &lt;character&gt;   &lt;character&gt; &lt;integer&gt;\n##  ELGNDAYK         ELGNDAYK       ProtA Mitochondr...         3\n##  IAEESNFPFIK IAEESNFPFI...       ProtB       unknown         4\n##  SYGFNAAR         SYGFNAAR       ProtA Mitochondr...         3\n\nWe can now aggregate the peptide-level data into a new protein-level assay using the colMedians() aggregation function.\n\nfeat1 &lt;- aggregateFeatures(feat1, i = \"peptides\",\n                           fcol = \"Protein\",\n                           name = \"proteins\",\n                           fun = colMedians)\nfeat1\n##  An instance of class QFeatures containing 3 assays:\n##   [1] psms: SummarizedExperiment with 10 rows and 2 columns \n##   [2] peptides: SummarizedExperiment with 3 rows and 2 columns \n##   [3] proteins: SummarizedExperiment with 2 rows and 2 columns\nassay(feat1[[\"proteins\"]])\n##         S1   S2\n##  ProtA 3.5 13.5\n##  ProtB 8.5 18.5\n\n\n4.2.3 Subsetting and filtering\nThe link between the assays becomes apparent when we now subset the assays for protein A as shown below or using the subsetByFeature() function. This creates a new instance of class QFeatures containing assays with the expression data for protein, its peptides and their PSMs.\n\nfeat1[\"ProtA\", , ]\n##  An instance of class QFeatures containing 3 assays:\n##   [1] psms: SummarizedExperiment with 6 rows and 2 columns \n##   [2] peptides: SummarizedExperiment with 2 rows and 2 columns \n##   [3] proteins: SummarizedExperiment with 1 rows and 2 columns\n\nThe filterFeatures() function can be used to filter rows the assays composing a QFeatures object using the row data variables. We can for example retain rows that have a pval &lt; 0.05, which would only keep rows in the psms assay because the pval is only relevant for that assay.\n\nfilterFeatures(feat1, ~ pval &lt; 0.05)\n##  'pval' found in 1 out of 3 assay(s)\n##  No filter applied to the following assay(s) because one or more filtering variables are missing in the rowData: peptides, proteins.\n##  You can control whether to remove or keep the features using the 'keep' argument (see '?filterFeature').\n##  An instance of class QFeatures containing 3 assays:\n##   [1] psms: SummarizedExperiment with 4 rows and 2 columns \n##   [2] peptides: SummarizedExperiment with 0 rows and 2 columns \n##   [3] proteins: SummarizedExperiment with 0 rows and 2 columns\n\n\n\n\n\n\n\nQuestion\n\n\n\nAs the message above implies, it is also possible to apply a filter to only the assays that have a filtering variables by setting the keep variables.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nfilterFeatures(feat1, ~ pval &lt; 0.05, keep = TRUE)\n##  'pval' found in 1 out of 3 assay(s)\n##  No filter applied to the following assay(s) because one or more filtering variables are missing in the rowData: peptides, proteins.\n##  You can control whether to remove or keep the features using the 'keep' argument (see '?filterFeature').\n##  An instance of class QFeatures containing 3 assays:\n##   [1] psms: SummarizedExperiment with 4 rows and 2 columns \n##   [2] peptides: SummarizedExperiment with 3 rows and 2 columns \n##   [3] proteins: SummarizedExperiment with 2 rows and 2 columns\n\n\n\n\n\n\nOn the other hand, if we filter assay rows for those that localise to the mitochondrion, we retain the relevant protein, peptides and PSMs.\n\nfilterFeatures(feat1, ~ location == \"Mitochondrion\")\n##  'location' found in 3 out of 3 assay(s)\n##  An instance of class QFeatures containing 3 assays:\n##   [1] psms: SummarizedExperiment with 6 rows and 2 columns \n##   [2] peptides: SummarizedExperiment with 2 rows and 2 columns \n##   [3] proteins: SummarizedExperiment with 1 rows and 2 columns\n\n\n\n\n\n\n\nQuestion\n\n\n\nAs an exercise, let‚Äôs filter rows that do not localise to the mitochondrion.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nfilterFeatures(feat1, ~ location != \"Mitochondrion\")\n##  'location' found in 3 out of 3 assay(s)\n##  An instance of class QFeatures containing 3 assays:\n##   [1] psms: SummarizedExperiment with 4 rows and 2 columns \n##   [2] peptides: SummarizedExperiment with 1 rows and 2 columns \n##   [3] proteins: SummarizedExperiment with 1 rows and 2 columns\n\n\n\n\n\n\nYou can refer to the Quantitative features for mass spectrometry data vignette and the QFeatures manual page for more details about the class."
  },
  {
    "objectID": "pages/30-quant.html#creating-qfeatures-object",
    "href": "pages/30-quant.html#creating-qfeatures-object",
    "title": "4¬† Quantitative data",
    "section": "\n4.3 Creating QFeatures object",
    "text": "4.3 Creating QFeatures object\nWhile QFeatures objects can be created manually (see ?QFeatures for details), most users have a quantitative data in a spreadsheet or a data.frame. In such cases, the easiest is to use the readQFeatures function to extract the quantitative data and metadata columns. Below, we load the hlpsms dataframe that contains data for 28 PSMs from the TMT-10plex hyperLOPIT spatial proteomics experiment from (Christoforou et al. 2016). The ecol argument specifies that columns 1 to 10 contain quantitation data, and that the assay should be named psms in the returned QFeatures object, to reflect the nature of the data.\n\ndata(hlpsms)\nhl &lt;- readQFeatures(hlpsms, ecol = 1:10, name = \"psms\")\nhl\n##  An instance of class QFeatures containing 1 assays:\n##   [1] psms: SummarizedExperiment with 3010 rows and 10 columns\n\nBelow, we see that we can extract an assay using its index or its name. The individual assays are stored as SummarizedExperiment object and further access its quantitative data and metadata using the assay and rowData functions.\n\nhl[[1]]\n##  class: SummarizedExperiment \n##  dim: 3010 10 \n##  metadata(0):\n##  assays(1): ''\n##  rownames(3010): 1 2 ... 3009 3010\n##  rowData names(18): Sequence ProteinDescriptions ... RTmin markers\n##  colnames(10): X126 X127C ... X130N X131\n##  colData names(0):\nhl[[\"psms\"]]\n##  class: SummarizedExperiment \n##  dim: 3010 10 \n##  metadata(0):\n##  assays(1): ''\n##  rownames(3010): 1 2 ... 3009 3010\n##  rowData names(18): Sequence ProteinDescriptions ... RTmin markers\n##  colnames(10): X126 X127C ... X130N X131\n##  colData names(0):\nhead(assay(hl[[\"psms\"]]))\n##          X126      X127C       X127N      X128C       X128N      X129C\n##  1 0.12283431 0.08045915 0.070804055 0.09386901 0.051815695 0.13034383\n##  2 0.35268185 0.14162381 0.167523880 0.07843497 0.071087436 0.03214548\n##  3 0.01546089 0.16142297 0.086938133 0.23120844 0.114664348 0.09610188\n##  4 0.04702854 0.09288723 0.102012167 0.11125409 0.067969116 0.14155358\n##  5 0.01044693 0.15866147 0.167315736 0.21017494 0.147946673 0.07088253\n##  6 0.04955362 0.01215244 0.002477681 0.01297833 0.002988949 0.06253195\n##         X129N       X130C      X130N       X131\n##  1 0.17540095 0.040068658 0.11478839 0.11961594\n##  2 0.06686260 0.031961793 0.02810434 0.02957384\n##  3 0.15977819 0.010127118 0.08059400 0.04370403\n##  4 0.18015910 0.035329902 0.12166589 0.10014038\n##  5 0.17555789 0.007088253 0.02884754 0.02307803\n##  6 0.01726511 0.172651119 0.37007905 0.29732174\nhead(rowData(hl[[\"psms\"]]))\n##  DataFrame with 6 rows and 18 columns\n##       Sequence ProteinDescriptions NbProteins ProteinGroupAccessions\n##    &lt;character&gt;         &lt;character&gt;  &lt;integer&gt;            &lt;character&gt;\n##  1     SQGEIDk       Tetratrico...          1                 Q8BYY4\n##  2     YEAQGDk       Vacuolar p...          1                 P46467\n##  3     TTScDTk       C-type man...          1                 Q64449\n##  4     aEELESR       Liprin-alp...          1                 P60469\n##  5     aQEEAIk       Isoform 2 ...          2               P13597-2\n##  6    dGAVDGcR       Structural...          1                 Q6P5D8\n##    Modifications    qValue       PEP  IonScore NbMissedCleavages\n##      &lt;character&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;integer&gt;         &lt;integer&gt;\n##  1 K7(TMT6ple...     0.008   0.11800        27                 0\n##  2 K7(TMT6ple...     0.001   0.01070        27                 0\n##  3 C4(Carbami...     0.008   0.11800        11                 0\n##  4 N-Term(TMT...     0.002   0.04450        24                 0\n##  5 N-Term(Car...     0.001   0.00850        36                 0\n##  6 N-Term(TMT...     0.000   0.00322        26                 0\n##    IsolationInterference IonInjectTimems Intensity    Charge      mzDa\n##                &lt;integer&gt;       &lt;integer&gt; &lt;numeric&gt; &lt;integer&gt; &lt;numeric&gt;\n##  1                     0              70    335000         2   503.274\n##  2                     0              70    926000         2   520.267\n##  3                     0              70    159000         2   521.258\n##  4                     0              70    232000         2   531.785\n##  5                     0              70    212000         2   537.804\n##  6                     0              70    865000         2   539.761\n##         MHDa DeltaMassPPM     RTmin       markers\n##    &lt;numeric&gt;    &lt;numeric&gt; &lt;numeric&gt;   &lt;character&gt;\n##  1   1005.54        -0.38     24.02       unknown\n##  2   1039.53         0.61     18.85       unknown\n##  3   1041.51         1.11     10.17       unknown\n##  4   1062.56         0.35     29.18       unknown\n##  5   1074.60         1.70     25.56 Plasma mem...\n##  6   1078.51        -0.67     21.27 Nucleus - ...\n\nFor further details on how to manipulate such objects, refer to the MultiAssayExperiment (Ramos et al. 2017) and SummarizedExperiment (Morgan et al. 2020) packages.\nIt is also possible to first create a SummarizedExperiment, and then only include it into a QFeatures object.\n\nse &lt;- readSummarizedExperiment(hlpsms, ecol = 1:10)\nse\n##  class: SummarizedExperiment \n##  dim: 3010 10 \n##  metadata(0):\n##  assays(1): ''\n##  rownames(3010): 1 2 ... 3009 3010\n##  rowData names(18): Sequence ProteinDescriptions ... RTmin markers\n##  colnames(10): X126 X127C ... X130N X131\n##  colData names(0):\n\n\nQFeatures(list(psm = se))\n##  An instance of class QFeatures containing 1 assays:\n##   [1] psm: SummarizedExperiment with 3010 rows and 10 columns\n\nAt this stage, i.e.¬†at the beginning of the analysis, whether you have a SummarizedExperiment or a QFeatures object, it is a good time to define the experimental design in the colData slot.\nExercise\nThe CPTAC spike-in study 6 (Paulovich et al. 2010) combines the Sigma UPS1 standard containing 48 different human proteins that are spiked in at 5 different concentrations (conditions A to E) into a constant yeast protein background. The sample were acquired in triplicate on different instruments in different labs. We are going to start with a subset of the CPTAC study 6 containing conditions A and B for a single lab.\n\n\n\n\nThe CPTAC spike-in study design (credit Lieven Clement, statOmics, Ghent University).\n\n\n\nThe peptide-level data, as processed by MaxQuant (Cox and Mann 2008) is available in the msdata package:\n\nbasename(f &lt;- msdata::quant(pattern = \"cptac\", full.names = TRUE))\n##  [1] \"cptac_a_b_peptides.txt\"\n\n\n\n\n\n\n\nQuestion\n\n\n\nRead these data in as either a SummarizedExperiment or a QFeatures object.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFrom the names of the columns, we see that the quantitative columns, starting with \"Intensity.\" (note the dot!) are at positions 56 to 61.\n\nnames(read.delim(f))\n##   [1] \"Sequence\"                 \"N.term.cleavage.window\"  \n##   [3] \"C.term.cleavage.window\"   \"Amino.acid.before\"       \n##   [5] \"First.amino.acid\"         \"Second.amino.acid\"       \n##   [7] \"Second.last.amino.acid\"   \"Last.amino.acid\"         \n##   [9] \"Amino.acid.after\"         \"A.Count\"                 \n##  [11] \"R.Count\"                  \"N.Count\"                 \n##  [13] \"D.Count\"                  \"C.Count\"                 \n##  [15] \"Q.Count\"                  \"E.Count\"                 \n##  [17] \"G.Count\"                  \"H.Count\"                 \n##  [19] \"I.Count\"                  \"L.Count\"                 \n##  [21] \"K.Count\"                  \"M.Count\"                 \n##  [23] \"F.Count\"                  \"P.Count\"                 \n##  [25] \"S.Count\"                  \"T.Count\"                 \n##  [27] \"W.Count\"                  \"Y.Count\"                 \n##  [29] \"V.Count\"                  \"U.Count\"                 \n##  [31] \"Length\"                   \"Missed.cleavages\"        \n##  [33] \"Mass\"                     \"Proteins\"                \n##  [35] \"Leading.razor.protein\"    \"Start.position\"          \n##  [37] \"End.position\"             \"Unique..Groups.\"         \n##  [39] \"Unique..Proteins.\"        \"Charges\"                 \n##  [41] \"PEP\"                      \"Score\"                   \n##  [43] \"Identification.type.6A_7\" \"Identification.type.6A_8\"\n##  [45] \"Identification.type.6A_9\" \"Identification.type.6B_7\"\n##  [47] \"Identification.type.6B_8\" \"Identification.type.6B_9\"\n##  [49] \"Experiment.6A_7\"          \"Experiment.6A_8\"         \n##  [51] \"Experiment.6A_9\"          \"Experiment.6B_7\"         \n##  [53] \"Experiment.6B_8\"          \"Experiment.6B_9\"         \n##  [55] \"Intensity\"                \"Intensity.6A_7\"          \n##  [57] \"Intensity.6A_8\"           \"Intensity.6A_9\"          \n##  [59] \"Intensity.6B_7\"           \"Intensity.6B_8\"          \n##  [61] \"Intensity.6B_9\"           \"Reverse\"                 \n##  [63] \"Potential.contaminant\"    \"id\"                      \n##  [65] \"Protein.group.IDs\"        \"Mod..peptide.IDs\"        \n##  [67] \"Evidence.IDs\"             \"MS.MS.IDs\"               \n##  [69] \"Best.MS.MS\"               \"Oxidation..M..site.IDs\"  \n##  [71] \"MS.MS.Count\"\n(i &lt;- grep(\"Intensity\\\\.\", names(read.delim(f))))\n##  [1] 56 57 58 59 60 61\n\nWe now read these data using the readSummarizedExperiment function. This peptide-level expression data will be imported into R as an instance of class SummarizedExperiment. We also use the fnames argument to set the row-names of the peptides assay to the peptide sequences and specify that the file is a tab-separated table.\n\ncptac_se &lt;- readSummarizedExperiment(f, ecol = i,\n                                     fnames = \"Sequence\",\n                                     sep = \"\\t\")\ncptac_se\n##  class: SummarizedExperiment \n##  dim: 11466 6 \n##  metadata(0):\n##  assays(1): ''\n##  rownames(11466): AAAAGAGGAGDSGDAVTK AAAALAGGK ... YYTVFDRDNNR\n##    YYTVFDRDNNRVGFAEAAR\n##  rowData names(65): Sequence N.term.cleavage.window ...\n##    Oxidation..M..site.IDs MS.MS.Count\n##  colnames(6): Intensity.6A_7 Intensity.6A_8 ... Intensity.6B_8\n##    Intensity.6B_9\n##  colData names(0):\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nBefore proceeding, we are going to clean up the sample names by removing the unnecessary Intensity prefix and annotate the experiment in the object‚Äôs colData.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncolnames(cptac_se) &lt;- sub(\"I.+\\\\.\", \"\", colnames(cptac_se))\ncptac_se$condition &lt;- sub(\"_[7-9]\", \"\", colnames(cptac_se))\ncptac_se$id &lt;- sub(\"^.+_\", \"\", colnames(cptac_se))\ncolData(cptac_se)\n##  DataFrame with 6 rows and 2 columns\n##         condition          id\n##       &lt;character&gt; &lt;character&gt;\n##  6A_7          6A           7\n##  6A_8          6A           8\n##  6A_9          6A           9\n##  6B_7          6B           7\n##  6B_8          6B           8\n##  6B_9          6B           9\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nThere are many row variables that aren‚Äôt useful here. Get rid or all of them but Sequence, Proteins, Leading.razor.protein, PEP, Score, Reverse, and Potential.contaminant.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nkeep_var &lt;- c(\"Sequence\", \"Proteins\", \"Leading.razor.protein\", \"PEP\",\n              \"Score\", \"Reverse\", \"Potential.contaminant\")\n\nrowData(cptac_se) &lt;- rowData(cptac_se)[, keep_var]"
  },
  {
    "objectID": "pages/30-quant.html#analysis-pipeline",
    "href": "pages/30-quant.html#analysis-pipeline",
    "title": "4¬† Quantitative data",
    "section": "\n4.4 Analysis pipeline",
    "text": "4.4 Analysis pipeline\nA typical quantitative proteomics data processing is composed of the following steps, which we are going to apply to the cptac data created above.\n\nData import\nExploratory data analysis (PCA)\nMissing data management (filtering and/or imputation)\nData cleaning\nTransformation and normalisation\nAggregation\nDownstream analysis\n\n\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(QFeatures)\nlibrary(limma)\n\n\n4.4.1 Missing values\nMissing values can be highly frequent in proteomics. There are two reasons supporting the existence of missing values, namely biological or technical.\n\nValues that are missing due to the absence (or extremely low concentration) of a protein are observed for biological reasons, and their pattern aren‚Äôt random (MNAR). A protein missing due to the suppression of its expression will not be missing at random: it will be missing in the condition in which it was suppressed, and be present in the condition where it is expressed.\nDue to its data-dependent acquisition, mass spectrometry isn‚Äôt capable of assaying all peptides in a sample. Peptides that are less abundant than some of their co-eluting ions, peptides that do not ionise well or peptides that do not get identified might be sporadically missing in the final quantitation table, despite their presence in the biological samples. Their absence patterns are (completely) random (MAR or MCAR) in such cases.\n\nOften, third party software that produce quantitative data use zeros instead of properly reporting missing values. We can use the zeroIsNA() function to replace the 0 by NA values in our cptac_se object and then explore the missing data patterns across columns and rows.\n\ncptac_se &lt;- zeroIsNA(cptac_se)\nnNA(cptac_se)\n##  $nNA\n##  DataFrame with 1 row and 2 columns\n##          nNA       pNA\n##    &lt;integer&gt; &lt;numeric&gt;\n##  1     31130  0.452497\n##  \n##  $nNArows\n##  DataFrame with 11466 rows and 3 columns\n##                 name       nNA       pNA\n##          &lt;character&gt; &lt;integer&gt; &lt;numeric&gt;\n##  1     AAAAGAGGAG...         4  0.666667\n##  2         AAAALAGGK         0  0.000000\n##  3        AAAALAGGKK         0  0.000000\n##  4     AAADALSDLE...         0  0.000000\n##  5     AAADALSDLE...         0  0.000000\n##  ...             ...       ...       ...\n##  11462 YYSIYDLGNN...         6  1.000000\n##  11463 YYTFNGPNYN...         3  0.500000\n##  11464    YYTITEVATR         4  0.666667\n##  11465 YYTVFDRDNN...         6  1.000000\n##  11466 YYTVFDRDNN...         6  1.000000\n##  \n##  $nNAcols\n##  DataFrame with 6 rows and 3 columns\n##           name       nNA       pNA\n##    &lt;character&gt; &lt;integer&gt; &lt;numeric&gt;\n##  1        6A_7      4743  0.413658\n##  2        6A_8      5483  0.478196\n##  3        6A_9      5320  0.463980\n##  4        6B_7      4721  0.411739\n##  5        6B_8      5563  0.485174\n##  6        6B_9      5300  0.462236\n\n\n\n\n\nDistribution of missing value (white). Peptides row with more missing values are moved towards the top of the figure.\n\n\n\nLet‚Äôs now explore these missing values:\n\nExplore the number or proportion of missing values across peptides and samples of the cptac_se data.\n\n\nbarplot(nNA(cptac_se)$nNAcols$pNA)\n\n\n\n\n\n\n\ntable(nNA(cptac_se)$nNArows$nNA)\n##  \n##     0    1    2    3    4    5    6 \n##  4059  990  884  717  934  807 3075\n\n\nRemove rows that have too many missing values. You can do this by hand or using the filterNA() function.\n\n\n## remove rows that have 4 or more NAs out of 6\ncptac_se &lt;- filterNA(cptac_se, pNA = 4/6)\n\n\n4.4.2 Imputation\nImputation is the technique of replacing missing data with probable values. This can be done with impute() method. As we have discussed above, there are however two types of missing values in mass spectrometry-based proteomics, namely data missing at random (MAR), and data missing not at random (MNAR). These two types of missing data, those missing at random, and those missing not at random, need to be imputed with different types of imputation methods (Lazar et al. 2016).\n\n\n\n\nMixed imputation method. Black cells represent presence of quantitation values and light grey corresponds to missing data. The two groups of interest are depicted in green and blue along the heatmap columns. Two classes of proteins are annotated on the left: yellow are proteins with randomly occurring missing values (if any) while proteins in brown are candidates for non-random missing value imputation.\n\n\n\n\n\n\n\nEffect of the nature of missing values on their imputation. Root-mean-square error (RMSE) observations standard deviation ratio (RSR), KNN and MinDet imputation. Lower (blue) is better.\n\n\n\nGenerally, it is recommended to use hot deck methods (nearest neighbour (left), maximum likelihood, ‚Ä¶) when data are missing at random.Conversely, MNAR features should ideally be imputed with a left-censor (minimum value (right), but not zero, ‚Ä¶) method.\nThere are various methods to perform data imputation, as described in ?impute. The imp4p package contains additional functionality, including some to estimate the randomness of missing data.\nThe general syntax for imputation is shown below, using the se_na2 object as an example:\n\ndata(se_na2)\n## impute missing values using knn imputation\nimpute(se_na2, method = \"knn\")\n##  Loading required namespace: impute\n##  Imputing along margin 1 (features/rows).\n##  Warning in knnimp(x, k, maxmiss = rowmax, maxp = maxp): 12 rows with more than 50 % entries missing;\n##   mean imputation used for these rows\n##  class: SummarizedExperiment \n##  dim: 689 16 \n##  metadata(3): MSnbaseFiles MSnbaseProcessing MSnbaseVersion\n##  assays(1): ''\n##  rownames(689): AT1G09210 AT1G21750 ... AT4G11150 AT4G39080\n##  rowData names(2): nNA randna\n##  colnames(16): M1F1A M1F4A ... M2F8B M2F11B\n##  colData names(1): nNA\n\n\n\n\n\n\n\nQuestion\n\n\n\nFollowing the example above, apply a mixed imputation, using knn for data missing at random and the zero imputation for data missing not at random. Hint: the randna variable defines which features are assumed to be missing at random.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nimpute(se_na2, \"mixed\",\n       randna = rowData(se_na2)$randna,\n       mar = \"knn\", mnar = \"zero\")\n##  class: SummarizedExperiment \n##  dim: 689 16 \n##  metadata(3): MSnbaseFiles MSnbaseProcessing MSnbaseVersion\n##  assays(1): ''\n##  rownames(689): AT1G09210 AT1G21750 ... AT4G11150 AT4G39080\n##  rowData names(2): nNA randna\n##  colnames(16): M1F1A M1F4A ... M2F8B M2F11B\n##  colData names(1): nNA\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhen assessing missing data imputation methods, such as in Lazar et al.¬†(2016), one often replaces values with missing data, imputes these with a method of choice, then quantifies the difference between original (expected) and observed (imputed) values. Here, using the se_na2 data, use this strategy to assess the difference between knn and Bayesian PCA imputation.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nimp1 &lt;- impute(se_na2, method = \"knn\")\n##  Imputing along margin 1 (features/rows).\n##  Warning in knnimp(x, k, maxmiss = rowmax, maxp = maxp): 12 rows with more than 50 % entries missing;\n##   mean imputation used for these rows\nimp2 &lt;- impute(se_na2, method = \"bpca\")\n##  Loading required namespace: pcaMethods\n##  Imputing along margin 1 (features/rows).\nsummary(abs(assay(imp1)[is.na(assay(se_na2))] - assay(imp2)[is.na(assay(se_na2))]))\n##       Min.   1st Qu.    Median      Mean   3rd Qu.      Max. \n##  5.332e-05 6.594e-03 1.535e-02 2.315e-02 2.855e-02 2.579e-01\nsummary(as.numeric(na.omit(assay(se_na2))))\n##     Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   0.0170  0.1865  0.2440  0.2500  0.3080  0.6587\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nWhen assessing the impact of missing value imputation on real data, one can‚Äôt use the strategy above. Another useful approach is to assess the impact of the imputation method on the distribution of the quantitative data. For instance, here is the intensity distribution of the se_na2 data. Verify the effect of applying knn, zero, MinDet and bpca on this distribution.\n\nplot(density(na.omit(assay(se_na2))))\n\n\n\nIntensity disctribution of the naset data.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncls &lt;- c(\"black\", \"red\", \"blue\", \"steelblue\", \"orange\")\nplot(density(na.omit(assay(se_na2))), col = cls[1])\nlines(density(assay(impute(se_na2, method = \"knn\"))), col = cls[2])\n##  Imputing along margin 1 (features/rows).\n##  Warning in knnimp(x, k, maxmiss = rowmax, maxp = maxp): 12 rows with more than 50 % entries missing;\n##   mean imputation used for these rows\nlines(density(assay(impute(se_na2, method = \"zero\"))), col = cls[3])\nlines(density(assay(impute(se_na2, method = \"MinDet\"))), col = cls[4])\n##  Imputing along margin 2 (samples/columns).\nlines(density(assay(impute(se_na2, method = \"bpca\"))), col = cls[5])\n##  Imputing along margin 1 (features/rows).\nlegend(\"topright\", legend = c(\"orig\", \"knn\", \"zero\", \"MinDet\", \"bpca\"),\n       col = cls, lwd = 2, bty = \"n\")\n\n\n\n\n\n\n\n\n\n\n\n\nTip: When downstream analyses permit, it might be safer not to impute data and deal explicitly with missing values. Indeed missing data imputation is not straightforward, and is likely to dramatically fail when a high proportion of data is missing (10s of %). It is possible to keep NAs when performing hypothesis tests1, but (generally) not to perform a principal component analysis.\n\n4.4.3 Identification quality control\nAs discussed in the previous chapter, PSMs are deemed relevant after comparison against hits from a decoy database. The origin of these hits is recorded with + in the Reverse variable:\n\ntable(rowData(cptac_se)$Reverse)\n##  \n##          + \n##  7572   12\n\nSimilarly, a proteomics experiment is also searched against a database of contaminants:\n\ntable(rowData(cptac_se)$Potential.contaminant)\n##  \n##          + \n##  7558   26\n\nLet‚Äôs visualise some of the cptac‚Äôs metadata using standard ggplot2 code:\n\n\n\n\n\n\nQuestion\n\n\n\nVisualise the identification score and the posterior probability probability (PEP) distributions from forward and reverse hits and interpret the figure.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nrowData(cptac_se) |&gt;\n    as_tibble() |&gt;\n    ggplot(aes(x = Score, colour = Reverse)) +\n    geom_density()\n\n\n\n\n\n\n\n\nrowData(cptac_se) |&gt;\n    as_tibble() |&gt;\n    ggplot(aes(x = PEP, colour = Reverse)) +\n    geom_density()\n\n\n\n\n\n\n\n\n\n\n\n\nNote: it is also possible to compute and visualise protein groups as connected components starting from a quantitative dataset such as a SummarizedExperiment. See the Using quantitative data section in the Understanding protein groups with adjacency matrices vignette.\n\n4.4.4 Creating the QFeatures data\nWe can now create our QFeatures object using the SummarizedExperiment as shown below.\n\ncptac &lt;- QFeatures(list(peptides = cptac_se))\ncptac\n##  An instance of class QFeatures containing 1 assays:\n##   [1] peptides: SummarizedExperiment with 7584 rows and 6 columns\n\nWe should also assign the QFeatures column data with the SummarizedExperiment slot.\n\ncolData(cptac) &lt;- colData(cptac_se)\n\nNote that it is also possible to directly create a QFeatures object with the readQFeatures() function and the same arguments as the readSummarizedExperiment() used above. In addition, most functions used above and below work on single SummarizedExperiment objects or assays within a QFeatures object.\n\n4.4.5 Filtering out contaminants and reverse hits\n\n\n\n\n\n\nQuestion\n\n\n\nUsing the filterFeatures() function, filter out the reverse and contaminant hits, and also retain those that have a posterior error probability smaller than 0.05.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncptac &lt;-\n    cptac |&gt;\n    filterFeatures(~ Reverse != \"+\") |&gt;\n    filterFeatures(~ Potential.contaminant != \"+\") |&gt;\n    filterFeatures(~ PEP &lt; 0.05)\n##  'Reverse' found in 1 out of 1 assay(s)\n##  'Potential.contaminant' found in 1 out of 1 assay(s)\n##  'PEP' found in 1 out of 1 assay(s)\n\n\n\n\n\n\n\n4.4.6 Log-transformation and normalisation\nThe two code chunks below log-transform and normalise using the assay i as input and adding a new one names as defined by name.\n\ncptac &lt;- logTransform(cptac, i = \"peptides\",\n                      name = \"log_peptides\")\n\n\n\n\n\n\n\nQuestion\n\n\n\nUse the normalize() method to normalise the data. The syntax is the same as logTransform(). Use the center.median method.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncptac &lt;- normalize(cptac, i = \"log_peptides\",\n                   name = \"lognorm_peptides\",\n                   method = \"center.median\")\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nVisualise the result of the transformations above. The plotDensities() function from the limma package is very convenient, but feel free to use boxplots, violin plots, or any other visualisation that you deem useful to assess the tranformations.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\npar(mfrow = c(1, 3))\nlimma::plotDensities(assay(cptac[[\"peptides\"]]))\nlimma::plotDensities(assay(cptac[[\"log_peptides\"]]))\nlimma::plotDensities(assay(cptac[[\"lognorm_peptides\"]]))\n\n\n\nThree peptide level assays: raw data, log transformed and normalised.\n\n\n\n\n\n\n\n\n\n4.4.7 Aggregation\n\n\n\n\n\n\nQuestion\n\n\n\nUse median aggregation to aggregation peptides into protein values. This is not necessarily the best choice, as we will see later, but a good start.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ncptac &lt;-\n    aggregateFeatures(cptac,\n                      \"lognorm_peptides\",\n                      name = \"proteins_med\",\n                      fcol = \"Leading.razor.protein\",\n                      fun = colMedians,\n                      na.rm = TRUE)\n\n\n\n\n\n\nLooking at the .n row variable computed during the aggregation, we see that most proteins result from the aggregation of 5 peptides or less, while very few proteins are accounted for by tens of peptides.\n\ntable(rowData(cptac[[\"proteins_med\"]])$.n)\n##  \n##    1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19 \n##  327 234 167 132  84  73  62  49  49  29  29  24  20  13  15  12   4   6  11 \n##   20  21  22  23  24  25  26  28  29  30  31  32  34  37  38  39  42  51  52 \n##    5   7   4   7   2   2   3   1   3   1   2   2   1   1   1   1   2   1   1 \n##   62 \n##    1\n\n\n4.4.8 Principal component analysis\n\nlibrary(factoextra)\n\npca_pep &lt;-\n    cptac[[\"lognorm_peptides\"]] |&gt;\n    filterNA() |&gt;\n    assay() |&gt;\n    t() |&gt;\n    prcomp(scale = TRUE, center = TRUE) |&gt;\n    fviz_pca_ind(habillage = cptac$condition, title = \"Peptides\")\n\npca_prot &lt;-\n    cptac[[\"proteins_med\"]] |&gt;\n    filterNA() |&gt;\n    assay() |&gt;\n    t() |&gt;\n    prcomp() |&gt;\n    fviz_pca_ind(habillage = cptac$condition,\n                 title = \"Proteins (median aggregation)\")\n\n\nlibrary(patchwork)\npca_pep + pca_prot\n\n\n\nPeptide and protein level PCA analyses.\n\n\n\n\n4.4.9 Visualisation\nBelow, we use the longFormat() function to extract the quantitative and row data in a long format, that can be directly reused by the tidyverse tools.\n\nlongFormat(cptac[\"P02787ups|TRFE_HUMAN_UPS\", ,\n                 c(\"lognorm_peptides\", \"proteins_med\")]) |&gt;\n    as_tibble() |&gt;\n    mutate(condition = ifelse(grepl(\"A\", colname), \"A\", \"B\")) |&gt;\n    ggplot(aes(x = colname, y = value, colour = rowname, shape = condition)) +\n    geom_point(size = 3) +\n    geom_line(aes(group = rowname)) +\n    facet_grid(~ assay) +\n    ggtitle(\"P02787ups|TRFE_HUMAN_UPS\")\n\n\n\nPeptide and protein expression profile.\n\n\n\nWe can also visualise the assays withing a QFeatures object and their relation.\n\nplot(cptac)\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nThe example above shows a simple linear relationship between assays. Create a more interesting one by applying a different normalisation method on the log_peptides assay and aggreate that new normalised peptide assay. Visualise the relationship with plot(), as above.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nnormalize(cptac, \"log_peptides\",\n          name = \"logquantiles_peptides\",\n          method = \"quantiles\") |&gt;\n    aggregateFeatures(\n        \"logquantiles_peptides\",\n        name = \"proteins_med2\",\n        fcol = \"Leading.razor.protein\",\n        fun = colMedians,\n        na.rm = TRUE) |&gt;\n    plot()\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.4.10 Statistical analysis\nR in general and Bioconductor in particular are well suited for the statistical analysis of quantitative proteomics data. Several packages provide dedicated resources for proteomics data:\n\nMSstats and MSstatsTMT: A set of tools for statistical relative protein significance analysis in Data dependent (DDA), SRM, Data independent acquisition (DIA) and TMT experiments.\nmsmsTests: Statistical tests for label-free LC-MS/MS data by spectral counts, to discover differentially expressed proteins between two biological conditions. Three tests are available: Poisson GLM regression, quasi-likelihood GLM regression, and the negative binomial of the edgeR package. All can be readily applied on MSnSet instances produced, for example by MSnID.\nDEP provides an integrated analysis workflow for the analysis of mass spectrometry proteomics data for differential protein expression or differential enrichment.\nMSqRob: The MSqRob package allows a user to do quantitative protein-level statistical inference on LC-MS proteomics data. More specifically, our package makes use of peptide-level input data, thus correcting for unbalancedness and peptide-specific biases. As previously shown (Goeminne et al.¬†(2015)), this approach is both more sensitive and specific than summarizing peptide-level input to protein-level values. Model estimates are stabilized by ridge regression, empirical Bayes variance estimation and downweighing of outliers. Currently, only label-free proteomics data types are supported. msqrob2 is now available and makes use of the QFeatures infrastructure.\nproDA accounts for missing values in label-free mass spectrometry data without imputation. The package implements a probabilistic dropout model that ensures that the information from observed and missing values are properly combined. It adds empirical Bayesian priors to increase power to detect differentially abundant proteins.\n\nOthers, while not specfic to proteomics, are also recommended, such as the limma package. When analysing spectral counting data, methods for high throughput sequencing data are applicable. Below, we illustrate how to apply a typical edgeR test to count data using the msms.edgeR function from the msmsTests package.\nBelow, we are going to perform our statistical analysis on the protein data using limma.\n\nprots &lt;- getWithColData(cptac, \"proteins_med\")\n##  Warning: 'experiments' dropped; see 'drops()'\n##  Warning: Ignoring redundant column names in 'colData(x)':\n\nThe limma package is the precursor package that enables the consistent application of linear models to normalliy distributed omics data in general, and microarrays in particular.\nThe limma package implements an empirical Bayes method that borrows information across features to estimate the standard error and calculate (so called moderated) t statistics. This approach is demonstrably more powerful that a standard t-tests when the number of samples is low.\nThe code chunk below illustrates how to set up the model, fit it, and apply the empirical Bayes moderation.\n\nlibrary(limma)\ndesign &lt;- model.matrix(~ prots$condition)\nfit &lt;- lmFit(assay(prots), design)\n##  Warning: Partial NA coefficients for 25 probe(s)\nfit &lt;- eBayes(fit)\n\nFinally, the topTable() function is used the extract the results for the coefficient of interest.\n\nres &lt;-\n    topTable(fit, coef = \"prots$condition6B\", number = Inf) |&gt;\n    rownames_to_column(\"protein\") |&gt;\n    as_tibble() |&gt;\n    mutate(TP = grepl(\"ups\", protein))\n\nNote the warning about partial NA coefficients for 23 probes:\n\nna_coefs &lt;-\n    filter(res, is.na(t)) |&gt;\n    pull(protein)\nassay(prots[na_coefs, ])\n##                                 6A_7      6A_8       6A_9       6B_7\n##  P00167ups|CYB5_HUMAN_UPS        NaN       NaN        NaN -0.7840558\n##  P01112ups|RASH_HUMAN_UPS        NaN       NaN        NaN -1.5564896\n##  P05413ups|FABPH_HUMAN_UPS       NaN       NaN        NaN -3.3419480\n##  P08758ups|ANXA5_HUMAN_UPS       NaN       NaN        NaN -2.7973872\n##  sp|P06704|CDC31_YEAST           NaN       NaN        NaN -1.2032046\n##  sp|P25574|EMC1_YEAST      -1.506177 -1.983737 -0.7795009        NaN\n##  sp|P32608|RTG2_YEAST            NaN       NaN        NaN        NaN\n##  sp|P32769|HBS1_YEAST            NaN -1.384031 -0.7285780        NaN\n##  sp|P34217|PIN4_YEAST            NaN       NaN        NaN -0.8378614\n##  sp|P34237|CASP_YEAST            NaN       NaN        NaN -1.5645172\n##  sp|P38166|SFT2_YEAST      -1.585685 -1.076707        NaN        NaN\n##  sp|P40056|GET2_YEAST            NaN -1.091696 -1.4014211        NaN\n##  sp|P40533|TED1_YEAST            NaN       NaN        NaN -2.0491876\n##  sp|P43582|WWM1_YEAST            NaN       NaN        NaN -0.5538711\n##  sp|P46965|SPC1_YEAST            NaN -3.428771 -3.6321984        NaN\n##  sp|P48363|PFD3_YEAST            NaN       NaN        NaN -0.1904905\n##  sp|P53044|UFD1_YEAST            NaN       NaN        NaN -2.3937896\n##  sp|P53091|MCM6_YEAST            NaN -1.253779 -1.6910302        NaN\n##  sp|P53115|INO80_YEAST           NaN       NaN        NaN -2.7183960\n##  sp|P53893|RIA1_YEAST      -1.830856       NaN -1.5232812        NaN\n##  sp|Q05029|BCH1_YEAST      -1.857855 -1.760501        NaN        NaN\n##  sp|Q07540|FRDA_YEAST            NaN       NaN        NaN -2.3850242\n##  sp|Q08645|FOLE_YEAST            NaN       NaN        NaN -1.7269184\n##  sp|Q12255|NYV1_YEAST            NaN       NaN        NaN -2.8706030\n##  sp|Q12280|IQG1_YEAST            NaN       NaN        NaN -2.5636389\n##                                  6B_8       6B_9\n##  P00167ups|CYB5_HUMAN_UPS  -2.0282987 -1.1230809\n##  P01112ups|RASH_HUMAN_UPS         NaN -1.5618192\n##  P05413ups|FABPH_HUMAN_UPS        NaN -3.8907081\n##  P08758ups|ANXA5_HUMAN_UPS -2.0137585 -2.0894752\n##  sp|P06704|CDC31_YEAST     -2.1252371 -1.5844104\n##  sp|P25574|EMC1_YEAST             NaN        NaN\n##  sp|P32608|RTG2_YEAST      -4.4424189 -2.7873186\n##  sp|P32769|HBS1_YEAST             NaN        NaN\n##  sp|P34217|PIN4_YEAST      -0.1316397 -0.1989392\n##  sp|P34237|CASP_YEAST      -1.6600291 -1.6877463\n##  sp|P38166|SFT2_YEAST             NaN        NaN\n##  sp|P40056|GET2_YEAST             NaN        NaN\n##  sp|P40533|TED1_YEAST             NaN -1.7474812\n##  sp|P43582|WWM1_YEAST      -0.7360990 -0.7207043\n##  sp|P46965|SPC1_YEAST             NaN        NaN\n##  sp|P48363|PFD3_YEAST             NaN -0.5087747\n##  sp|P53044|UFD1_YEAST      -1.5138746        NaN\n##  sp|P53091|MCM6_YEAST             NaN        NaN\n##  sp|P53115|INO80_YEAST            NaN -2.7504079\n##  sp|P53893|RIA1_YEAST             NaN        NaN\n##  sp|Q05029|BCH1_YEAST             NaN        NaN\n##  sp|Q07540|FRDA_YEAST             NaN -2.0325180\n##  sp|Q08645|FOLE_YEAST             NaN -1.5257358\n##  sp|Q12255|NYV1_YEAST             NaN -2.8237317\n##  sp|Q12280|IQG1_YEAST      -2.0547564 -2.4648042\n\nWe can now visualise the results using a volcano plot:\n\np &lt;- res |&gt;\n    ggplot(aes(x = logFC, y = -log10(adj.P.Val))) +\n    geom_point(aes(colour = TP)) +\n    geom_vline(xintercept = c(-1, 1)) +\n    geom_hline(yintercept = -log10(0.05)) +\n    scale_color_manual(values = c(\"black\",\"red\"))\n\nUsing the pipeline described above, we would would identify a single differentially expressed protein at an 5 percent FDR but miss out the other 36 expected spike-in proteins.\nWe can assess our results in terms of true/false postitves/negatives:\n\nTrue positives: 1\nFalse positives: 0\nTrue negatives: 1330\nFalse negatives: 32"
  },
  {
    "objectID": "pages/30-quant.html#summary-exercice",
    "href": "pages/30-quant.html#summary-exercice",
    "title": "4¬† Quantitative data",
    "section": "\n4.5 Summary exercice",
    "text": "4.5 Summary exercice\nAs shown below, it is possible to substantially improve these results by aggregating features using a robust summarisation (available as MsCoreUtils::robustSummary()), i.e robust regression with M-estimation using Huber weights, as described in section 2.7 in (Sticker et al. 2019).\n\n\n\n\nAggregation using robust summarisation.\n\n\n\n\nTrue positives: 21\nFalse positives: 2\nTrue negatives: 1340\nFalse negatives: 12\n\nRepeat and adapt what we have seen here using, for example, the robustSummary() function."
  },
  {
    "objectID": "pages/30-quant.html#footnotes",
    "href": "pages/30-quant.html#footnotes",
    "title": "4¬† Quantitative data",
    "section": "",
    "text": "Still, it is recommended to explore missingness as part of the exploratory data analysis.‚Ü©Ô∏é"
  },
  {
    "objectID": "pages/95-annex.html#sec-raw2",
    "href": "pages/95-annex.html#sec-raw2",
    "title": "5¬† Annex",
    "section": "\n5.1 Raw MS data under the hood: the mzR package",
    "text": "5.1 Raw MS data under the hood: the mzR package\nThe mzR package is a direct interface to the proteowizard code base. It includes a substantial proportion of pwiz‚Äôs C/C++ code for fast and efficient parsing of these large raw data files.\nLet‚Äôs start by using some raw data files from the msdata package. After loading it, we use the proteomics() function to return the full file names for two raw data files. We will start by focusing on the second one.\n\nf &lt;- msdata::proteomics(full.names = TRUE)\nf\n##  [1] \"/usr/local/lib/R/site-library/msdata/proteomics/MRM-standmix-5.mzML.gz\"                                                \n##  [2] \"/usr/local/lib/R/site-library/msdata/proteomics/MS3TMT10_01022016_32917-33481.mzML.gz\"                                 \n##  [3] \"/usr/local/lib/R/site-library/msdata/proteomics/MS3TMT11.mzML\"                                                         \n##  [4] \"/usr/local/lib/R/site-library/msdata/proteomics/TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML.gz\"\n##  [5] \"/usr/local/lib/R/site-library/msdata/proteomics/TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01.mzML.gz\"\n(f2 &lt;- grep(\"20141210\", f, value = TRUE))\n##  [1] \"/usr/local/lib/R/site-library/msdata/proteomics/TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML.gz\"\n\nThe three main functions of mzR are\n\n\nopenMSfile to create a file handle to a raw data file\n\nheader to extract metadata about the spectra contained in the file\n\npeaks to extract one or multiple spectra of interest.\n\nOther functions such as instrumentInfo, or runInfo can be used to gather general information about a run.\n\nlibrary(mzR)\n##  Loading required package: Rcpp\nms &lt;- openMSfile(f2)\nms\n##  Mass Spectrometry file handle.\n##  Filename:  TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML.gz \n##  Number of scans:  7534\n\n\nhd &lt;- header(ms)\ndim(hd)\n##  [1] 7534   31\nnames(hd)\n##   [1] \"seqNum\"                     \"acquisitionNum\"            \n##   [3] \"msLevel\"                    \"polarity\"                  \n##   [5] \"peaksCount\"                 \"totIonCurrent\"             \n##   [7] \"retentionTime\"              \"basePeakMZ\"                \n##   [9] \"basePeakIntensity\"          \"collisionEnergy\"           \n##  [11] \"ionisationEnergy\"           \"lowMZ\"                     \n##  [13] \"highMZ\"                     \"precursorScanNum\"          \n##  [15] \"precursorMZ\"                \"precursorCharge\"           \n##  [17] \"precursorIntensity\"         \"mergedScan\"                \n##  [19] \"mergedResultScanNum\"        \"mergedResultStartScanNum\"  \n##  [21] \"mergedResultEndScanNum\"     \"injectionTime\"             \n##  [23] \"filterString\"               \"spectrumId\"                \n##  [25] \"centroided\"                 \"ionMobilityDriftTime\"      \n##  [27] \"isolationWindowTargetMZ\"    \"isolationWindowLowerOffset\"\n##  [29] \"isolationWindowUpperOffset\" \"scanWindowLowerLimit\"      \n##  [31] \"scanWindowUpperLimit\"\n\n\nhead(peaks(ms, 117))\n##             mz intensity\n##  [1,] 399.9976         0\n##  [2,] 399.9991         0\n##  [3,] 400.0006         0\n##  [4,] 400.0021         0\n##  [5,] 400.2955         0\n##  [6,] 400.2970         0\nstr(peaks(ms, 1:5))\n##  List of 5\n##   $ : num [1:25800, 1:2] 400 400 400 400 400 ...\n##    ..- attr(*, \"dimnames\")=List of 2\n##    .. ..$ : NULL\n##    .. ..$ : chr [1:2] \"mz\" \"intensity\"\n##   $ : num [1:25934, 1:2] 400 400 400 400 400 ...\n##    ..- attr(*, \"dimnames\")=List of 2\n##    .. ..$ : NULL\n##    .. ..$ : chr [1:2] \"mz\" \"intensity\"\n##   $ : num [1:26148, 1:2] 400 400 400 400 400 ...\n##    ..- attr(*, \"dimnames\")=List of 2\n##    .. ..$ : NULL\n##    .. ..$ : chr [1:2] \"mz\" \"intensity\"\n##   $ : num [1:26330, 1:2] 400 400 400 400 400 ...\n##    ..- attr(*, \"dimnames\")=List of 2\n##    .. ..$ : NULL\n##    .. ..$ : chr [1:2] \"mz\" \"intensity\"\n##   $ : num [1:26463, 1:2] 400 400 400 400 400 ...\n##    ..- attr(*, \"dimnames\")=List of 2\n##    .. ..$ : NULL\n##    .. ..$ : chr [1:2] \"mz\" \"intensity\"\n\n\n\n\n\n\n\nQuestion\n\n\n\nLet‚Äôs extract the index of the MS2 spectrum with the highest base peak intensity and plot its spectrum. Is the data centroided or in profile mode?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nhd2 &lt;- hd[hd$msLevel == 2, ]\ni &lt;- which.max(hd2$basePeakIntensity)\nhd2[i, ]\n##       seqNum acquisitionNum msLevel polarity peaksCount totIonCurrent\n##  5404   5404           5404       2        1        275    2283283712\n##       retentionTime basePeakMZ basePeakIntensity collisionEnergy\n##  5404      2751.313   859.5032         354288224              45\n##       ionisationEnergy    lowMZ  highMZ precursorScanNum precursorMZ\n##  5404                0 100.5031 1995.63             5403    859.1722\n##       precursorCharge precursorIntensity mergedScan mergedResultScanNum\n##  5404               3          627820480         NA                  NA\n##       mergedResultStartScanNum mergedResultEndScanNum injectionTime\n##  5404                       NA                     NA    0.03474091\n##                                                   filterString\n##  5404 FTMS + p NSI d Full ms2 859.50@hcd45.00 [100.00-2000.00]\n##                                          spectrumId centroided\n##  5404 controllerType=0 controllerNumber=1 scan=5404       TRUE\n##       ionMobilityDriftTime isolationWindowTargetMZ isolationWindowLowerOffset\n##  5404                   NA                   859.5                          1\n##       isolationWindowUpperOffset scanWindowLowerLimit scanWindowUpperLimit\n##  5404                          1                  100                 2000\npi &lt;- peaks(ms, hd2[i, 1])\nplot(pi, type = \"h\")\n\n\n\n\n\n\nmz &lt;- hd2[i, \"basePeakMZ\"]\nplot(pi, type = \"h\", xlim = c(mz - 0.5, mz + 0.5))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion\n\n\n\nPick an MS1 spectrum and visually check whether it is centroided or in profile mode.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n## Zooming into spectrum 300 (an MS1 spectrum).\nj &lt;- 300\npj &lt;- peaks(ms, j)\nplot(pj, type = \"l\")\n\n\n\n\n\n\nmz &lt;- hd[j, \"basePeakMZ\"]\nplot(pj, type = \"l\", xlim = c(mz - 0.5, mz + 0.5))"
  },
  {
    "objectID": "pages/95-annex.html#sec-id2",
    "href": "pages/95-annex.html#sec-id2",
    "title": "5¬† Annex",
    "section": "\n5.2 PSM data under the hood",
    "text": "5.2 PSM data under the hood\nThere are two packages that can be used to parse mzIdentML files, namely mzR (that we have already used for raw data) and mzID. The major difference is that the former leverages C++ code from proteowizard and is hence faster than the latter (which uses the XML R package). They both work in similar ways.\n|Data type      |File format |Data structure |Package |\n|:--------------|:-----------|:--------------|:-------|\n|Identification |mzIdentML   |mzRident       |mzR     |\n|Identification |mzIdentML   |mzID           |mzID    |\nWhich of these packages is used by PSM() can be defined by the parser argument, as documented in ?PSM.\nmzID\nThe main functions are mzID to read the data into a dedicated data class and flatten to transform it into a data.frame.\n\nlibrary(mzID)\nidf &lt;- msdata::ident(full.names = TRUE)\nid &lt;- mzID(idf)\n##  reading TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid... DONE!\nid\n##  An mzID object\n##  \n##  Software used:   MS-GF+ (version: Beta (v10072))\n##  \n##  Rawfile:         /home/lg390/dev/01_svn/workflows/proteomics/TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##  \n##  Database:        /home/lg390/dev/01_svn/workflows/proteomics/erwinia_carotovora.fasta\n##  \n##  Number of scans: 5343\n##  Number of PSM's: 5656\n\nVarious data can be extracted from the mzID object, using one of the accessor functions such as database, software, scans, peptides, ‚Ä¶ The object can also be converted into a data.frame using the flatten function.\n\nhead(flatten(id))\n##                                       spectrumid scan number(s)\n##  1 controllerType=0 controllerNumber=1 scan=5782           5782\n##  2 controllerType=0 controllerNumber=1 scan=6037           6037\n##  3 controllerType=0 controllerNumber=1 scan=5235           5235\n##  4 controllerType=0 controllerNumber=1 scan=5397           5397\n##  5 controllerType=0 controllerNumber=1 scan=6075           6075\n##  6 controllerType=0 controllerNumber=1 scan=5761           5761\n##    acquisitionnum passthreshold rank calculatedmasstocharge\n##  1           5782          TRUE    1              1080.2321\n##  2           6037          TRUE    1              1002.2115\n##  3           5235          TRUE    1              1189.2800\n##  4           5397          TRUE    1               960.5365\n##  5           6075          TRUE    1              1264.3419\n##  6           5761          TRUE    1              1268.6501\n##    experimentalmasstocharge chargestate ms-gf:denovoscore ms-gf:evalue\n##  1                1080.2325           3               174 1.086033e-20\n##  2                1002.2089           3               245 1.988774e-19\n##  3                1189.2836           3               264 5.129649e-19\n##  4                 960.5365           3               178 5.163566e-18\n##  5                1264.3409           3               252 4.356914e-17\n##  6                1268.6429           2               138 4.658952e-17\n##    ms-gf:pepqvalue ms-gf:qvalue ms-gf:rawscore ms-gf:specevalue\n##  1               0            0            147     3.764831e-27\n##  2               0            0            214     6.902626e-26\n##  3               0            0            211     1.778789e-25\n##  4               0            0            154     1.792541e-24\n##  5               0            0            188     1.510364e-23\n##  6               0            0            123     1.618941e-23\n##    assumeddissociationmethod isotopeerror isdecoy post pre end start\n##  1                       HCD            0   FALSE    S   R  84    50\n##  2                       HCD            0   FALSE    R   K 315   288\n##  3                       HCD            0   FALSE    A   R 224   192\n##  4                       HCD            0   FALSE    -   R 290   264\n##  5                       HCD            0   FALSE    F   R 153   119\n##  6                       HCD            0   FALSE    Y   K 286   264\n##    accession length                                       description\n##  1   ECA1932    155                        outer membrane lipoprotein\n##  2   ECA1147    434                                    trigger factor\n##  3   ECA0013    295                ribose-binding periplasmic protein\n##  4   ECA1731    290                                         flagellin\n##  5   ECA1443    298      UTP--glucose-1-phosphate uridylyltransferase\n##  6   ECA1444    468 6-phosphogluconate dehydrogenase, decarboxylating\n##                                 pepseq modified modification\n##  1 PVQIQAGEDSNVIGALGGAVLGGFLGNTIGGGSGR    FALSE         &lt;NA&gt;\n##  2        TQVLDGLINANDIEVPVALIDGEIDVLR    FALSE         &lt;NA&gt;\n##  3   TKGLNVMQNLLTAHPDVQAVFAQNDEMALGALR    FALSE         &lt;NA&gt;\n##  4         SQILQQAGTSVLSQANQVPQTVLSLLR    FALSE         &lt;NA&gt;\n##  5 PIIGDNPFVVVLPDVVLDESTADQTQENLALLISR    FALSE         &lt;NA&gt;\n##  6             WTSQSSLDLGEPLSLITESVFAR    FALSE         &lt;NA&gt;\n##                                                                 idFile\n##  1 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\n##  2 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\n##  3 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\n##  4 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\n##  5 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\n##  6 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid\n##                                                           spectrumFile\n##  1 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##  2 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##  3 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##  4 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##  5 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##  6 TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzML\n##                databaseFile\n##  1 erwinia_carotovora.fasta\n##  2 erwinia_carotovora.fasta\n##  3 erwinia_carotovora.fasta\n##  4 erwinia_carotovora.fasta\n##  5 erwinia_carotovora.fasta\n##  6 erwinia_carotovora.fasta\n\nmzR\nThe mzR interface provides a similar interface. It is however much faster as it does not read all the data into memory and only extracts relevant data on demand. It has also accessor functions such as softwareInfo, mzidInfo, ‚Ä¶ (use showMethods(classes = \"mzRident\", where = \"package:mzR\")) to see all available methods.\n\nlibrary(mzR)\nid2 &lt;- openIDfile(idf)\nid2\n##  Identification file handle.\n##  Filename:  TMT_Erwinia_1uLSike_Top10HCD_isol2_45stepped_60min_01-20141210.mzid \n##  Number of psms:  5759\nsoftwareInfo(id2)\n##  [1] \"MS-GF+ Beta (v10072) \"                        \n##  [2] \"ProteoWizard MzIdentML 3.0.21263 ProteoWizard\"\n\nThe identification data can be accessed as a data.frame with the psms accessor.\n\nhead(psms(id2))\n##                                       spectrumID chargeState rank\n##  1 controllerType=0 controllerNumber=1 scan=5782           3    1\n##  2 controllerType=0 controllerNumber=1 scan=6037           3    1\n##  3 controllerType=0 controllerNumber=1 scan=5235           3    1\n##  4 controllerType=0 controllerNumber=1 scan=5397           3    1\n##  5 controllerType=0 controllerNumber=1 scan=6075           3    1\n##  6 controllerType=0 controllerNumber=1 scan=5761           2    1\n##    passThreshold experimentalMassToCharge calculatedMassToCharge\n##  1          TRUE                1080.2325              1080.2321\n##  2          TRUE                1002.2089              1002.2115\n##  3          TRUE                1189.2836              1189.2800\n##  4          TRUE                 960.5365               960.5365\n##  5          TRUE                1264.3409              1264.3419\n##  6          TRUE                1268.6429              1268.6501\n##                               sequence peptideRef modNum isDecoy post pre\n##  1 PVQIQAGEDSNVIGALGGAVLGGFLGNTIGGGSGR       Pep1      0   FALSE    S   R\n##  2        TQVLDGLINANDIEVPVALIDGEIDVLR       Pep2      0   FALSE    R   K\n##  3   TKGLNVMQNLLTAHPDVQAVFAQNDEMALGALR       Pep3      0   FALSE    A   R\n##  4         SQILQQAGTSVLSQANQVPQTVLSLLR       Pep4      0   FALSE    -   R\n##  5 PIIGDNPFVVVLPDVVLDESTADQTQENLALLISR       Pep5      0   FALSE    F   R\n##  6             WTSQSSLDLGEPLSLITESVFAR       Pep6      0   FALSE    Y   K\n##    start end DatabaseAccess DBseqLength DatabaseSeq\n##  1    50  84        ECA1932         155            \n##  2   288 315        ECA1147         434            \n##  3   192 224        ECA0013         295            \n##  4   264 290        ECA1731         290            \n##  5   119 153        ECA1443         298            \n##  6   264 286        ECA1444         468            \n##                                          DatabaseDescription scan.number.s.\n##  1                        ECA1932 outer membrane lipoprotein           5782\n##  2                                    ECA1147 trigger factor           6037\n##  3                ECA0013 ribose-binding periplasmic protein           5235\n##  4                                         ECA1731 flagellin           5397\n##  5      ECA1443 UTP--glucose-1-phosphate uridylyltransferase           6075\n##  6 ECA1444 6-phosphogluconate dehydrogenase, decarboxylating           5761\n##    acquisitionNum\n##  1           5782\n##  2           6037\n##  3           5235\n##  4           5397\n##  5           6075\n##  6           5761"
  },
  {
    "objectID": "pages/99-si.html",
    "href": "pages/99-si.html",
    "title": "6¬† Additional materials and help",
    "section": "",
    "text": "References"
  },
  {
    "objectID": "pages/99-si.html#additional-materials",
    "href": "pages/99-si.html#additional-materials",
    "title": "6¬† Additional materials and help",
    "section": "6.1 Additional materials",
    "text": "6.1 Additional materials\n\nThe Single-cell proteomics data analysis using QFeatures and scp workshop is provided as two vignettes. The first one provides a general introduction to the QFeatures class in the general context of mass spectrometry-based proteomics data manipulation. The second vignette focuses on single-cell application and introduces the scp package (Vanderaa and Gatto 2021) as an extension of QFeatures. This second vignette also provides exercises that give the attendee the opportunity to apply the learned concepts to reproduce a published analysis on a subset of a real data set.\nThe SpectraTutorials package provides three different vignettes:\n\nSeamless Integration of Mass Spectrometry Data from Different Sources: describes import/export of MS data from/to files in different format as well as processing and handling of MS data with the Spectra package.\nSpectra: an Expandable Infrastructure to Handle Mass Spectrometry Data: explains the concept of backends in Spectra, their properties, use cases along with performance considerations.\nMS/MS Spectra Matching with the MetaboAnnotation Package: explains how the Spectra package can be used together with the r BiocStyle::Biocpkg(\"MetaboAnnotation\") package in LC-MS/MS annotation workflows for untargeted metabolomics data.\n\nA tutorial presenting Use Cases and Examples for Annotation of Untargeted Metabolomics Data using the MetaboAnnotation and MetaboCoreUtils packages (Rainer et al. 2022).\nExploring and analyzing LC-MS data with Spectra and xcms provides an overview of recent developments in Bioconductor to work with mass spectrometry (MsExperiment, Spectra) and specifically LC-MS data (xcms) and walks through the preprocessing of a small data set emphasizing on selection of data-dependent settings for the individual pre-processing steps."
  },
  {
    "objectID": "pages/99-si.html#questions-and-help",
    "href": "pages/99-si.html#questions-and-help",
    "title": "6¬† Additional materials and help",
    "section": "6.2 Questions and help",
    "text": "6.2 Questions and help\nFor questions about specific software or their usage, please refer to the software‚Äôs github issue page, or use the Bioconductor support site."
  }
]